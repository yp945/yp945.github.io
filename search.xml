<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[evm源码分析第三篇]]></title>
    <url>%2F2019%2F07%2F11%2Fevm-analysis-3%2F</url>
    <content type="text"><![CDATA[上一篇我们介绍了创建合约的交易是如何执行的，这一篇我们分析普通交易是如何在evm里面被执行的 1234567if contractCreation &#123; ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)&#125; else &#123; // Increment the nonce for the next transaction st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1) ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value)&#125; 如果是普通的交易，则会把调用方nonce+1 然后 执行evm.call。 evm.call方法和evm.create方法大致相同，我们来说说不一样的地方。call方法调用的是一个存在的合约地址的合约，所以不用创建合约账户。如果call方法发现本地也没有合约接收方的账户，则需要创建一个接收方的账户，并更新本地状态数据库。 call 方法或者create方法执行完毕，则会调用st.refundGas()方法计算需要退还的gas. 在拜占庭版本的黄皮书规范中，只有SELFDESTRUCT和SSTORE(当将一个非0位置上的数置为0时候）这两个opcode会触发refund。单个交易执行结束时，累计refund的gas量不能超过当前交易执行上下文的消耗的gasUsed的一半。 12345678910111213141516171819func (st *StateTransition) refundGas() &#123; // Apply refund counter, capped to half of the used gas. refund := st.gasUsed() / 2 if refund &gt; st.state.GetRefund() &#123; refund = st.state.GetRefund() &#125; //st.gs 代表交易完成还剩下的gas值 st.gas += refund // Return ETH for remaining gas, exchanged at the original rate. remaining := new(big.Int).Mul(new(big.Int).SetUint64(st.gas), st.gasPrice) st.state.AddBalance(st.msg.From(), remaining) //gas pool 默认初始值为区块gas limit, 每执行一次交易，将会从gas pool中减去st.msg.Gas(), //既然产生了remaining， 那肯定也需要将这些值加回到原来的gas pool. // Also return remaining gas to the block gas counter so it is // available for the next transaction. st.gp.AddGas(st.gas)&#125; 最后实际退回给交易发起者的gas为：remaining = gas执行交易剩余 + 累计refund 这里引用一篇博客的介绍这个gas refund 机制 最后计算合约产生的gas总数，加入到矿工账户，作为矿工收入。 最后我们回到第一节的ApplyTransaction（）函数上，这时候还有最后一步就是更新state root了。 接下来填充receipt的各项值，然后返回。 总结一下 交易流程到EVM执行大致流程如下 1234567891011121314151617/*The State Transitioning ModelA state transition is a change made when a transaction is applied to the current world stateThe state transitioning model does all the necessary work to work out a valid new state root.1) Nonce handling2) Pre pay gas3) Create a new state object if the recipient is \0*324) Value transfer== If contract creation == 4a) Attempt to run transaction data 4b) If valid, use result as code for the new state object== end ==5) Run Script section6) Derive new state root*/]]></content>
      <categories>
        <category>ethereum</category>
        <category>evm</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>evm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[evm源码分析第二篇]]></title>
    <url>%2F2019%2F07%2F11%2Fevm-analysis-2%2F</url>
    <content type="text"><![CDATA[这一篇我们主要分析交易是如何被evm解释器解释执行的。 首先我们接着上一篇进入create函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// create creates a new contract using code as deployment code.func (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address) ([]byte, common.Address, uint64, error) &#123; // Depth check execution. Fail if we're trying to execute above the // limit. if evm.depth &gt; int(params.CallCreateDepth) &#123; return nil, common.Address&#123;&#125;, gas, ErrDepth &#125; if !evm.CanTransfer(evm.StateDB, caller.Address(), value) &#123; return nil, common.Address&#123;&#125;, gas, ErrInsufficientBalance &#125; nonce := evm.StateDB.GetNonce(caller.Address()) evm.StateDB.SetNonce(caller.Address(), nonce+1) // Ensure there's no existing contract already at the designated address contractHash := evm.StateDB.GetCodeHash(address) if evm.StateDB.GetNonce(address) != 0 || (contractHash != (common.Hash&#123;&#125;) &amp;&amp; contractHash != emptyCodeHash) &#123; return nil, common.Address&#123;&#125;, 0, ErrContractAddressCollision &#125; // Create a new account on the state snapshot := evm.StateDB.Snapshot() evm.StateDB.CreateAccount(address) if evm.ChainConfig().IsEIP158(evm.BlockNumber) &#123; evm.StateDB.SetNonce(address, 1) &#125; evm.Transfer(evm.StateDB, caller.Address(), address, value) // Initialise a new contract and set the code that is to be used by the EVM. // The contract is a scoped environment for this execution context only. contract := NewContract(caller, AccountRef(address), value, gas) contract.SetCodeOptionalHash(&amp;address, codeAndHash) if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 &#123; return nil, address, gas, nil &#125; if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 &#123; evm.vmConfig.Tracer.CaptureStart(caller.Address(), address, true, codeAndHash.code, gas, value) &#125; start := time.Now() ret, err := run(evm, contract, nil, false) // check whether the max code size has been exceeded maxCodeSizeExceeded := evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; len(ret) &gt; params.MaxCodeSize // if the contract creation ran successfully and no errors were returned // calculate the gas required to store the code. If the code could not // be stored due to not enough gas set an error and let it be handled // by the error checking condition below. if err == nil &amp;&amp; !maxCodeSizeExceeded &#123; createDataGas := uint64(len(ret)) * params.CreateDataGas if contract.UseGas(createDataGas) &#123; evm.StateDB.SetCode(address, ret) &#125; else &#123; err = ErrCodeStoreOutOfGas &#125; &#125; 1.1 判断evm执行栈深度不能超过1024， 1.2 发送方持有的以太坊数量大于此次合约交易金额。 1.3 获取合约调用者账户nonce，然后将nonce+1存入stateDB 1.4 根据合约地址获取合约hash值 1.5 记录一个状态快照，用来失败回滚。 1.6 为这个合约地址创建一个合约账户，并为这个合约账户设置nonce值为1 1.5 产生以太坊资产转移，发送方地址账户金额减value值，合约账户的金额加value值。 1.6 根据发送方地址和合约地址，以及金额value 值和gas，合约代码和代码hash值，创建一个合约对象 1.7 设置合约对象的bytecode, bytecodehash和 合约地址 1.8 run方法来执行合约，内部调用evm的解析器来执行合约指令，如果是预编译好的合约，则预编译执行合约就行 接下来主要看run方法是如何执行合约的 1234567891011121314151617181920212223242526// run runs the given contract and takes care of running precompiles with a fallback to the byte code interpreter.func run(evm *EVM, contract *Contract, input []byte, readOnly bool) ([]byte, error) &#123; if contract.CodeAddr != nil &#123; precompiles := PrecompiledContractsHomestead if evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123; precompiles = PrecompiledContractsByzantium &#125; if p := precompiles[*contract.CodeAddr]; p != nil &#123; return RunPrecompiledContract(p, input, contract) &#125; &#125; for _, interpreter := range evm.interpreters &#123; if interpreter.CanRun(contract.Code) &#123; if evm.interpreter != interpreter &#123; // Ensure that the interpreter pointer is set back // to its current value upon return. defer func(i Interpreter) &#123; evm.interpreter = i &#125;(evm.interpreter) evm.interpreter = interpreter &#125; return interpreter.Run(contract, input, readOnly) &#125; &#125; return nil, ErrNoCompatibleInterpreter&#125; run方法来执行合约，内部调用evm的解析器来执行合约指令，如果是预编译好的合约，则执行预编译合约就行。 这一部分我们看可以看到evm里面是用一个解释器数组合单独的解释器来存储解释器对象的，这可能是为了后面方便扩展多个解释器，因为从目前的代码来看，就使用了一个解释器。 选择好解释器后接下来就是具体解释字节码的过程了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// 循环解释执行合约代码的inpput data, 如果执行没有错误产生，则返回执行结果，// 有一点非常重要，那就是如果执行过程中有任何错误，那将会被认为是一个revert并且消耗所有gas的操作，除非是一个errExecutionReverted，那将以为这是一个revert并且保持所有gas退回操作。func (in *EVMInterpreter) Run(contract *Contract, input []byte, readOnly bool) (ret []byte, err error) &#123; if in.intPool == nil &#123; in.intPool = poolOfIntPools.get() defer func() &#123; poolOfIntPools.put(in.intPool) in.intPool = nil &#125;() &#125; // Increment the call depth which is restricted to 1024 in.evm.depth++ defer func() &#123; in.evm.depth-- &#125;() // Make sure the readOnly is only set if we aren't in readOnly yet. // This makes also sure that the readOnly flag isn't removed for child calls. if readOnly &amp;&amp; !in.readOnly &#123; in.readOnly = true defer func() &#123; in.readOnly = false &#125;() &#125; // Reset the previous call's return data. It's unimportant to preserve the old buffer // as every returning call will return new data anyway. in.returnData = nil // Don't bother with the execution if there's no code. if len(contract.Code) == 0 &#123; return nil, nil &#125; var ( op OpCode // current opcode mem = NewMemory() // bound memory stack = newstack() // local stack // For optimisation reason we're using uint64 as the program counter. // It's theoretically possible to go above 2^64. The YP defines the PC // to be uint256. Practically much less so feasible. pc = uint64(0) // program counter cost uint64 // copies used by tracer pcCopy uint64 // needed for the deferred Tracer gasCopy uint64 // for Tracer to log gas remaining before execution logged bool // deferred Tracer should ignore already logged steps res []byte // result of the opcode execution function ) contract.Input = input // Reclaim the stack as an int pool when the execution stops defer func() &#123; in.intPool.put(stack.data...) &#125;() if in.cfg.Debug &#123; defer func() &#123; if err != nil &#123; if !logged &#123; in.cfg.Tracer.CaptureState(in.evm, pcCopy, op, gasCopy, cost, mem, stack, contract, in.evm.depth, err) &#125; else &#123; in.cfg.Tracer.CaptureFault(in.evm, pcCopy, op, gasCopy, cost, mem, stack, contract, in.evm.depth, err) &#125; &#125; &#125;() &#125; // 解释器循环执行指定，当遇到STOP RETURN 或者合约自毁 或者 当执行过程中遇到错误的时候， // 直到所有指令被执行结束，循环才会停止 for atomic.LoadInt32(&amp;in.evm.abort) == 0 &#123; if in.cfg.Debug &#123; // Capture pre-execution values for tracing. logged, pcCopy, gasCopy = false, pc, contract.Gas &#125; // Get the operation from the jump table and validate the stack to ensure there are // enough stack items available to perform the operation. op = contract.GetOp(pc) operation := in.cfg.JumpTable[op] if !operation.valid &#123; return nil, fmt.Errorf("invalid opcode 0x%x", int(op)) &#125; if err = operation.validateStack(stack); err != nil &#123; return nil, err &#125; // If the operation is valid, enforce and write restrictions if err = in.EnforceRestrictions(op, operation, stack); err != nil &#123; return nil, err &#125; var memorySize uint64 // calculate the new memory size and expand the memory to fit // the operation if operation.memorySize != nil &#123; memSize, overflow := bigUint64(operation.memorySize(stack)) if overflow &#123; return nil, errGasUintOverflow &#125; // memory is expanded in words of 32 bytes. Gas // is also calculated in words. if memorySize, overflow = math.SafeMul(toWordSize(memSize), 32); overflow &#123; return nil, errGasUintOverflow &#125; &#125; // consume the gas and return an error if not enough gas is available. // cost is explicitly set so that the capture state defer method can get the proper cost cost, err = operation.gasCost(in.gasTable, in.evm, contract, stack, mem, memorySize) if err != nil || !contract.UseGas(cost) &#123; return nil, ErrOutOfGas &#125; if memorySize &gt; 0 &#123; mem.Resize(memorySize) &#125; if in.cfg.Debug &#123; in.cfg.Tracer.CaptureState(in.evm, pc, op, gasCopy, cost, mem, stack, contract, in.evm.depth, err) logged = true &#125; // execute the operation res, err = operation.execute(&amp;pc, in, contract, mem, stack) // verifyPool is a build flag. Pool verification makes sure the integrity // of the integer pool by comparing values to a default value. if verifyPool &#123; verifyIntegerPool(in.intPool) &#125; // if the operation clears the return data (e.g. it has returning data) // set the last return to the result of the operation. if operation.returns &#123; in.returnData = res &#125; switch &#123; case err != nil: return nil, err case operation.reverts: return res, errExecutionReverted case operation.halts: return res, nil case !operation.jumps: pc++ &#125; &#125; return nil, nil&#125; 这是执行的主要过程代码，接收三个参数，contract对象， input（因为是一个合约调用的交易，所以这里为nil）readonly 标志位，这个标志位只有在staticcall的时候是true的，其他的调用都是false; 接下来我们逐步分析执行过程 判断解释器的intPool为nil，则先创建一个intPool,然后将新创建的intPool放入poolOfIntPools evm 调用堆栈+1 解释器循环执行指定，当遇到STOP RETURN 或者合约自毁 或者 当执行过程中遇到错误的时候， 直到所有指令被执行结束，循环才会停止。 3.1 循环首先获取当前pc 计数器， 然后从jumptable里面拿出要执行的opcode, opcode是以太坊虚拟机指令，一共不超过256个，正好一个byte大小能装下。下面展示了一个 sha3的opteration ​ execute表示指令对应的执行方法​ gasCost表示执行这个指令需要消耗的gas​ validateStack计算是不是解析器栈溢出​ memorySize用于计算operation的占用内存大小 3.2 根据不同的指令，指令的memorysize等，调用operation.gasCost()方法计算执行operation指令需要消耗的gas。 3.3 调用operation.execute(&amp;pc, in.evm, contract, mem, stack)执行指令对应的方法。 3.4 operation.reverts值是true或者operation.halts值是true的指令，会跳出主循环，否则继续遍历下个op。 3.5 operation指令集里面有4个特殊的指令LOG0，LOG1，LOG2，LOG3，它们的指令执行方法makeLog()会产生日志数据，日志内容包括EVM解析栈内容，指令内存数据，区块信息，合约信息等。这些日志数据会写入到tx的Receipt的logs里面，并存入本地levleldb数据库。 至此创建一个合约的交易大致分析完成。具体的每个opcode的执行以及每个opcode消耗gas都需要对应不同的执行再去详细的了解，这一点可以通过跑测试用例，然后一步一步debug下去，就可以大致了解整个流程了。 下一篇我们会分析一个普通的交易是如何执行的，也就是toAddress不为0的情况]]></content>
      <categories>
        <category>ethereum</category>
        <category>evm</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>evm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[evm源码分析第一篇]]></title>
    <url>%2F2019%2F07%2F11%2Fevm-analysis-1%2F</url>
    <content type="text"><![CDATA[evm源码分析分为3篇去讲解，所有的代码解析基于以太坊go-ethereum-1.8.23-release 源码结构runtime 包下的文件在实际运行的geth客户端中并没有被调用到，只是作为开发人员测试使用。 core/vm/runtime/env.go 设置evm运行环境，并返回新的evm对象 core/vm/runtime/fuzz.go fuzz使得开发者可以随机测试evm代码，详见go-fuzz工具 core/vm/runtime/runtime.go 设置evm运行环境，并执行相应的evm代码 下面的文件为实际的使用到的evm的代码文件 core/vm/analysis.go 分析指令跳转目标 core/vm/common.go 存放常用工具方法 core/vm/contract.go 合约数据结构 core/vm/contracts.go 存放预编译好的合约 core/vm/errors.go 定义一些常见错误 core/vm/evm.go evm对于解释器提供的一些操作接口 core/vm/gas.go 计算一级指令耗费gas core/vm/gas_table.go 各种操作的gas消耗计算表 core/vm/gen_structlog.go 生成structlog的 序列化json和反序列化方法 core/vm/instructions.go 所有指令集的实现函数 core/vm/interface.go 定义常用操作接口 core/vm/interpreter.go evm 指令解释器 core/vm/intpool.go 常量池 core/vm/jump_table.go 指令跳转表 core/vm/logger.go 状态日志 core/vm/logger_json.go json形式日志 core/vm/memory.go evm 可操作内存 core/vm/memory_table.go evm内存操作表，衡量一些操作耗费内存大小 core/vm/opcodes.go 定义操作码的名称和编号 core/vm/stacks.go evm栈操作 core/vm/stack_table.go evm栈验证函数 上述对要介绍的evm代码进行了一个简单的介绍，接下来将详细的分析其中的代码。 从交易提交说起我们将会从一个交易的提交开始讲起，当一个geth客户端接收到其他节点提交的交易后，它会首先将这笔交易提交给evm进行处理。 12345678910111213func (w *worker) commitTransaction(tx *types.Transaction, coinbase common.Address) ([]*types.Log, error) &#123; snap := w.current.state.Snapshot() receipt, _, err := core.ApplyTransaction(w.config, w.chain, &amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;w.current.header.GasUsed, *w.chain.GetVMConfig()) if err != nil &#123; w.current.state.RevertToSnapshot(snap) return nil, err &#125; w.current.txs = append(w.current.txs, tx) w.current.receipts = append(w.current.receipts, receipt) return receipt.Logs, nil&#125; 一笔交易提交到EVM前的主要过程就是上述代码所描述的 创建当前stateDB的snapshot， 创建snapshot其实就是将leveldb的revisionId自增1，然后将这个revisionId加入到revisionId列表里，然后返回创建的id。 将交易发送到evm，执行交易， 这步骤后面会重点分析，这个就是我们这次文章主要分析的重点EVM的执行交易过程。 判断执行结果是否出错，如果出错，则回滚snapshot。 首先找到在revisionId列表里面找到需要回滚的revisionId， 然后将此revisionId里面的所有snapshot依次回滚。 将当前交易加入到交易列表 将交易收据加入到交易收据列表 接下来我们主要分析ApplyTransaction函数 12345678910111213141516171819202122232425262728293031323334353637383940// ApplyTransaction 尝试将一次交易的执行写入数据库，并且为执行环境准备输入参数。它返回交易的收据。// 如果gasg 使用完，或者交易执行出现error，则表示该块无效。func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, uint64, error) &#123; msg, err := tx.AsMessage(types.MakeSigner(config, header.Number)) if err != nil &#123; return nil, 0, err &#125; // 创建一个新的evm执行上下文环境 context := NewEVMContext(msg, header, bc, author) // 创建一个包含所有相关信息的新环境， 包括事务和调用机制 vmenv := vm.NewEVM(context, statedb, config, cfg) // 将事务应用于当前状态(包含在env中) _, gas, failed, err := ApplyMessage(vmenv, msg, gp) if err != nil &#123; return nil, 0, err &#125; // Update the state with pending changes var root []byte if config.IsByzantium(header.Number) &#123; statedb.Finalise(true) &#125; else &#123; root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes() &#125; *usedGas += gas //创建一个新的收据为这笔交易，存储中间状态根和gas使用情况 // based on the eip phase, we're passing whether the root touch-delete accounts. receipt := types.NewReceipt(root, failed, *usedGas) receipt.TxHash = tx.Hash() receipt.GasUsed = gas //如果这笔交易是创建一个合约， 存储合约地址在收据里面 if msg.To() == nil &#123; receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce()) &#125; // 设置收据日志和创建布隆过滤器 receipt.Logs = statedb.GetLogs(tx.Hash()) receipt.Bloom = types.CreateBloom(types.Receipts&#123;receipt&#125;) return receipt, gas, err&#125; AsMessage 函数123456789101112131415func (tx *Transaction) AsMessage(s Signer) (Message, error) &#123; msg := Message&#123; nonce: tx.data.AccountNonce, gasLimit: tx.data.GasLimit, gasPrice: new(big.Int).Set(tx.data.Price), to: tx.data.Recipient, amount: tx.data.Amount, data: tx.data.Payload, checkNonce: true, &#125; var err error msg.from, err = Sender(s, tx) return msg, err&#125; 将tx 里面的数据填充到msg里面, 这个过程主要是将交易里面的form address 利用 ecrevoer函数恢复出来。 NewEVMContext 函数1234567891011121314151617181920212223// NewEVMContext creates a new context for use in the EVM.func NewEVMContext(msg Message, header *types.Header, chain ChainContext, author *common.Address) vm.Context &#123; //如果不能得到一个明确的author,那就从区块头里面解析author var beneficiary common.Address //如果函数参数里面的author为nil,则从区块头里面解析author， 这里不叫coinbase 主要是为了区别ehthash与clique引擎 if author == nil &#123; beneficiary, _ = chain.Engine().Author(header) // Ignore error, we're past header validation &#125; else &#123; beneficiary = *author &#125; return vm.Context&#123; CanTransfer: CanTransfer, Transfer: Transfer, GetHash: GetHashFn(header, chain), Origin: msg.From(), Coinbase: beneficiary, BlockNumber: new(big.Int).Set(header.Number), Time: new(big.Int).Set(header.Time), Difficulty: new(big.Int).Set(header.Difficulty), GasLimit: header.GasLimit, GasPrice: new(big.Int).Set(msg.GasPrice()), &#125;&#125; 填充vm.Context的各项内容，并返回一个Context对象 NewEVM函数123456789101112131415161718192021222324252627282930313233func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM &#123; evm := &amp;EVM&#123; Context: ctx, StateDB: statedb, vmConfig: vmConfig, chainConfig: chainConfig, chainRules: chainConfig.Rules(ctx.BlockNumber), interpreters: make([]Interpreter, 0, 1), &#125; if chainConfig.IsEWASM(ctx.BlockNumber) &#123; // to be implemented by EVM-C and Wagon PRs. // if vmConfig.EWASMInterpreter != "" &#123; // extIntOpts := strings.Split(vmConfig.EWASMInterpreter, ":") // path := extIntOpts[0] // options := []string&#123;&#125; // if len(extIntOpts) &gt; 1 &#123; // options = extIntOpts[1..] // &#125; // evm.interpreters = append(evm.interpreters, NewEVMVCInterpreter(evm, vmConfig, options)) // &#125; else &#123; // evm.interpreters = append(evm.interpreters, NewEWASMInterpreter(evm, vmConfig)) // &#125; panic("No supported ewasm interpreter yet.") &#125; //vmConfig.EVMInterpreter 将会被使用在EVM-C， 这里不会使用。 //因为我们希望内置的EVM作为出错转移的备用选项 evm.interpreters = append(evm.interpreters, NewEVMInterpreter(evm, vmConfig)) evm.interpreter = evm.interpreters[0] return evm&#125; 这个函数主要是根据当前的区块号以及相关配置，设置EVM的解释器.这里可以看到以太坊已经在为后面EWASM 虚拟机做准备了。 ApplyMessage函数123456// ApplyMessage 通过给定的message计算新的DB状态，继而改变旧的DB状态// ApplyMessage 返回EVM执行的返回结果和gas使用情况（包括gas refunds）和error(如果有错误出现)。// 如果一个错误总是作为一个core error 出现，那么这个message将永远不会被这个区块所接受。func ApplyMessage(evm *vm.EVM, msg Message, gp *GasPool) ([]byte, uint64, bool, error) &#123; return NewStateTransition(evm, msg, gp).TransitionDb()&#125; 这个函数的分为两个函数执行一个是NewStateTransition 函数，这个函数主要是设置一些交易执行的必要参数。 TransitionDb 这个函数则是主要负责执行交易，影响Db状态。 TransitionDb 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// TransitionDB 函数通过 apply message 将会改变state 并且返回 包含gas使用情况的结果。// 如果执行失败，将会返回一个error, 这个error代表一个共识错误。func (st *StateTransition) TransitionDb() (ret []byte, usedGas uint64, failed bool, err error) &#123; //进行最初的检查， if err = st.preCheck(); err != nil &#123; return &#125; msg := st.msg sender := vm.AccountRef(msg.From()) homestead := st.evm.ChainConfig().IsHomestead(st.evm.BlockNumber) contractCreation := msg.To() == nil // Pay intrinsic gas gas, err := IntrinsicGas(st.data, contractCreation, homestead) if err != nil &#123; return nil, 0, false, err &#125; if err = st.useGas(gas); err != nil &#123; return nil, 0, false, err &#125; var ( evm = st.evm // vm errors do not effect consensus and are therefor // not assigned to err, except for insufficient balance // error. vmerr error ) if contractCreation &#123; ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value) &#125; else &#123; // Increment the nonce for the next transaction st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1) ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value) &#125; if vmerr != nil &#123; log.Debug("VM returned with error", "err", vmerr) // The only possible consensus-error would be if there wasn't // sufficient balance to make the transfer happen. The first // balance transfer may never fail. if vmerr == vm.ErrInsufficientBalance &#123; return nil, 0, false, vmerr &#125; &#125; st.refundGas() st.state.AddBalance(st.evm.Coinbase, new(big.Int).Mul(new(big.Int).SetUint64(st.gasUsed()), st.gasPrice)) return ret, st.gasUsed(), vmerr != nil, err&#125; preCheck 函数主要进行执行交易前的检查，目前包含下面两个步骤 1.1 检查msg 里面的nonce值与db里面存储的账户的nonce值是否一致。 1.2 buyGas方法主要是判断交易账户是否可以支付足够的gas执行交易，如果可以支付，则设置stateTransaction 的gas值 和 initialGas 值。并且从交易执行账户扣除相应的gas值。 先获取固定交易的基础费用，根据当前分叉版本和交易类型来决定基础费用，如果是创建合约则是至少是53000gas,如果是普通交易则至少是21000gas ，如果data部分不为空，则具体来说是按字节收费：字节为0的收4gas，字节不为0收68gas，所以你会看到很多做合约优化的，目的就是减少数据中不为0的字节数量，从而降低油费消耗。具体代码如下 12345678910111213141516171819202122232425262728293031323334//IntrinsicGas 计算给定数据的固定gas消耗func IntrinsicGas(data []byte, contractCreation, homestead bool) (uint64, error) &#123; // Set the starting gas for the raw transaction var gas uint64 if contractCreation &amp;&amp; homestead &#123; gas = params.TxGasContractCreation &#125; else &#123; gas = params.TxGas &#125; // 通过事务数据量增加所需的气体 if len(data) &gt; 0 &#123; // 零字节和非零字节的定价不同 var nz uint64 //获取非零字节的个数 for _, byt := range data &#123; if byt != 0 &#123; nz++ &#125; &#125; // 防止所需gas超过最大限制 if (math.MaxUint64-gas)/params.TxDataNonZeroGas &lt; nz &#123; return 0, vm.ErrOutOfGas &#125; //计算非0字节的gas消耗 gas += nz * params.TxDataNonZeroGas z := uint64(len(data)) - nz if (math.MaxUint64-gas)/params.TxDataZeroGas &lt; z &#123; return 0, vm.ErrOutOfGas &#125; gas += z * params.TxDataZeroGas &#125; return gas, nil&#125; 根据contractCreation这个变量判断这是一个普通交易还是一个合约创建交易，如果是合约创建交易，则会进入下面的代码 12345// Create creates a new contract using code as deployment code.func (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) &#123; contractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address())) return evm.create(caller, &amp;codeAndHash&#123;code: code&#125;, gas, value, contractAddr)&#125; crypto.CreateAddress 主要是利用账户地址和nonce进行rlp编码后取后20字节得到一个新的合约地址，因此合约地址其实是可以提前计算出来的，这也是很多合约地址是靓号的原因。 这一篇主要分析了交易执行前的一些准备工作，包括创建EVM，计算交易金额，设置交易对象，计算交易gas花销；下一篇主要是分析evm虚拟机解析器通过合约指令，执行智能合约代码的过程。]]></content>
      <categories>
        <category>ethereum</category>
        <category>evm</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>evm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Move IR 示例代码解读]]></title>
    <url>%2F2019%2F07%2F10%2Flibra-moveIR-exampleCode%2F</url>
    <content type="text"><![CDATA[Move IR 示例代码解读本节描述如何在Move中间表示(IR)中编写事务脚本和模块。IR是即将到来的Move源代码语言的早期(且不稳定)先驱。Move IR是一个覆盖于Move字节码之上的薄薄的语法层，用于测试字节码验证器和虚拟机，它对开发人员不是特别友好。它的级别足够高，可以编写人类可读的代码，但又足够低，可以直接编译以移动字节码。 接下来，我将展示一些Move IR片段。关于如何在本地编译、运行和修改这些示例来学习。libra/language/README.md and libra/language/compiler/README.md解释了如何做到这一点。 编写事务脚本正如我们在Move事务脚本中解释的那样，用户编写事务脚本来请求对Libra区块链的全局存储的更新。几乎在任何事务脚本中都会出现两个重要的构建块:LibraAccount.T和LibraCoin.T。LibraAccount是模块的名称，T是该模块声明的资源的名称。这是一个通用的命名约定;模块声明的“main”类型通常命名为T。 当我们说一个用户“在Libra区块链上的地址0xff处有一个帐户”时，我们的意思是地址0xff持有LibraAccount.T的资源。每个非空地址都有一个LibraAccount.T资源。此资源存储帐户数据，如序列号、身份验证密钥和余额。Libra系统的任何部分想要与一个帐户进行交互，都必须从LibraAccount.T资源中读取数据或者调用LibraAccount的模块的过程函数。 帐户余额是LibraCoin.T类型的资源，就像其他移动资源一样。LibraCoin类型的资源T可以存储在程序变量中，在过程之间传递，等等。 下面这些例子展示了如何与模块和资源交互。 1234567891011121314151617181920// 使用已经发布到链上的在一个地址上的Libra 模块// 0x0...0 (with 64 zeroes). 0x0其实是一个缩写，其中包含64个0import 0x0.LibraAccount;import 0x0.LibraCoin;main(payee: address, amount: u64) &#123; //IR代码的局部变量范围在整个函数过程，所有的局部变量声明都必须 //在程序的开始。声明和初始化变量是独立的操作，但是字节码验证器会阻止 //任何使用未初始化变量的尝试。 let coin: R#LibraCoin.T; //上面类型的R#部分是两个*类型注解* R#和V#之一(“Resource”和“unrestricted Value”的缩写)。这些注解 //必须匹配类型声明的类型(例如LibraCoin模块声明“resource T”或“struct T”) //获取sender的数量为amount的 LibraCoin.T资源，如果sender的余额不足balance，则会失败，这里amount // 是一个 unrestricted值，所以可以copy也可以move，但是因为后续不再使用， 所以最好还是move掉(move // 白皮书是里面写的是copy) coin = LibraAccount.withdraw_from_sender(move(amount)); // Move LibraCoin.T 资源进入payee账户，如果账户不存在，则步骤失败 LibraAccount.deposit(move(payee), move(coin)); //每一个函数过程必须要有个return, IR 编译器不会在没有写return的情况下，自己加上return，如果有返回 // 值，还要写上相应的返回值 return;&#125; 这个事务脚本有一个不幸的问题——如果收款人地址下没有帐户，它将失败。我们将通过修改脚本来解决这个问题，以便在收款人帐户不存在的情况下为其创建帐户。 123456789101112131415161718192021222324// 一个点对点支付的例子变体，即当账户不存在的时候，创建账户import 0x0.LibraAccount;import 0x0.LibraCoin;main(payee: address, amount: u64) &#123; let coin: R#LibraCoin.T; let account_exists: bool; // Acquire a LibraCoin.T resource with value `amount` from the sender&apos;s // account. This will fail if the sender&apos;s balance is less than `amount`. coin = LibraAccount.withdraw_from_sender(move(amount)); //这里调用LibraAccount的内置函数判断账户是否存在 account_exists = LibraAccount.exists(copy(payee)); if (!move(account_exists)) &#123; //通过发布一个LibraAccount.T 资源在接收方地址下的方式为接受者创建一个账户，如果 //账户资源已经存在，则失败 create_account(copy(payee)); &#125; LibraAccount.deposit(move(payee), move(coin)); return;&#125; 让我们看一个更复杂的例子。在本例中，我们将使用事务脚本向多个收件人付款，而不是只向一个收件人付款。 12345678910111213141516171819202122//多个收款人例子，这个例子将amount1+ amount2数量的资金转移到 收款1账户和收款2账户上import 0x0.LibraAccount;import 0x0.LibraCoin;main(payee1: address, amount1: u64, payee2: address, amount2: u64) &#123; let coin1: R#LibraCoin.T; let coin2: R#LibraCoin.T; let total: u64; total = move(amount1) + copy(amount2); coin1 = LibraAccount.withdraw_from_sender(move(total)); // This mutates `coin1`, which now has value `amount1`. // `coin2` has value `amount2`. //下面代码执行完后，coin1资源将拥有数量为amount1的Coin //coin2是一个有amount2数量coin的资源，withdraw是一个内置函数 coin2 = LibraCoin.withdraw(&amp;mut coin1, move(amount2)); // 执行支付 LibraAccount.deposit(move(payee1), move(coin1)); LibraAccount.deposit(move(payee2), move(coin2)); return;&#125; 编写模块现在，我们将把注意力转向编写自己的Move模块，而不是重用现有的LibraAccount和LibraCoin模块。考虑这种情况:Bob将在将来的某个时候在地址a创建一个帐户。Alice想为Bob“指定”一些资金，这样一旦Bob的账户创建好了，他就可以把这些资金转到他的账户中。但她也希望，如果鲍勃从未创建过账户，她也能收回自己的资金。 为了给Alice解决这个问题，我们将编写一个模块EarmarkedLibraCoin: 声明一个新的资源类型EarmarkedLibraCoin。这里面有Libra coin和接收方地址 允许Alice创建这样的类型并将其发布到她的帐户下(create过程)。 允许Bob claim资源(claim_for_receiver过程) 允许任何拥有EarmarkedLibraCoin.T资源的人销毁它，并获得底层的LibraCoin(unwarp的过程) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//一个用于收款地址指定coin的模块module EarmarkedLibraCoin &#123; import 0x0.LibraCoin; //T 定义了一个资源， 包含了Libra coin 和一个收款地址 resource T &#123; coin: R#LibraCoin.T, recipient: address &#125; // 为指定收款地址创建EarmarkedCoin 资源 // 在此交易发送方账户发布该资源 public create(coin: R#LibraCoin.T, recipient: address) &#123; let t: R#Self.T; //构造或者叫做打包一个类型为T的资源，只有EarmarkedCoin 模块的函数可以创建 EarmarkedCoin.T t = T &#123; coin: move(coin), recipient: move(recipient), &#125;; // 在此交易发送者账户下发布 earmarked coin //每个账户可以包含一个指定类型的资源，如果有相同类型的资源存在，此过程会失败 //move_to_sender是一个内置函数，作用是将资源发布到sender账户，支持泛型 move_to_sender&lt;T&gt;(move(t)); return; &#125; //允许交易发送者认领一枚指定给他的硬币。 public claim_for_recipient(earmarked_coin_address: address): R#Self.T &#123; let t: R#Self.T; //这里创建T资源的引用是为了防止资源只能被move一次，assert之后而不能进行return let t_ref: &amp;R#Self.T; let sender: address; //移除指定地址T类型的资源，如果指定地址没有类型T的资源，则失败 t = move_from&lt;T&gt;(move(earmarked_coin_address)); //拿到资源引用，方便后续assert t_ref = &amp;t; //获取此次交易发送者账户 sender = get_txn_sender(); //确保收款账户是交易发送者，如果断言失败，则此次交易不会造成任何影响， 原子操作。 //99是一个内部断言使用的error code,便于交易失败打印事件 assert(*(&amp;move(t_ref).recipient) == move(sender), 99); //返回获取到的资源，接下来应该使用unwarp获取资源里面的Libra coin了 return move(t); &#125; // 如果Bob的地址没有被创建，则Alice将会回收掉该资源 public claim_for_creator(): R#Self.T &#123; let t: R#Self.T; let coin: R#LibraCoin.T; let recipient: address; let sender: address; sender = get_txn_sender(); // This will fail if no resource of type T under the sender&apos;s address. t = move_from&lt;T&gt;(move(sender)); return move(t); &#125; // 从包装资源里面获取到Libra coin,并将它返回给调用者 public unwrap(t: R#Self.T): R#LibraCoin.T &#123; let coin: R#LibraCoin.T; let recipient: address; // 将t 资源进行解包，用T类型去接收，只有声明了T类型的模块才可以接收这个资源 T &#123; coin, recipient &#125; = move(t); //返回libra coin资源 return move(coin); &#125;&#125; 上述过程可以综述为：Alice可以创建一个事务脚本，调用create方法，参数为Bob的地址和libra coin资源，从而为Bob创建一个指定的coin在她的地址上。一旦创建了这个资源, Bob就可以通过从发送事务来声明coin。这将调用claim_for_receiver，然后将结果传递给unwrap，并将返回的LibraCoin存储在他希望的任何地方。如果Bob花了太长时间在创建一个帐户上，而Alice想要收回她的资金，她可以使用claim_for_creator和unwrap。将资金回收。 rust引用说明这里针对上述例子有个关于rust引用或者借用的说明，这也是针对白皮书里面的一些引用形式给一个解释 123456789let b = a; a绑定的资源A转移给b，b拥有这个资源Alet b = &amp;a; a绑定的资源A借给b使用，b只有资源A的读权限let b = &amp;mut a; a绑定的资源A借给b使用，b有资源A的读写权限let mut b = &amp;mut a; a绑定的资源A借给b使用，b有资源A的读写权限。同时，b可绑定到新的资源上面去(更新绑定的能力)let &amp;mut b = &amp;mut a; a 绑定的资源A借给b的引用使用，b的引用有资源A的读写权限。同时b的引用可以绑定到新的资源上面去(更新绑定能力)如果一个值有了可变引用，则不能再有不变引用，这部分内容可以仔细参考rust的引用与借用关系 例子讲解下面我会抽取libra github仓库里面的一些典型的例子来对move进行更加全面的解释。 下面这个示例是一个module 1234module Signature &#123; native public ed25519_verify(signature: bytearray, public_key: bytearray, message: bytearray): bool;&#125;这个模块是官方的算法验签名模块，正如白皮书里面说得到，move语言可以直接调用一些rust的函数实现，这个过程称之为navite,用navite标识。 下面这个示例是一个script，由一个main过程构成 123456import 0x0.LibraAccount;main (new_key: bytearray) &#123; LibraAccount.rotate_authentication_key(move(new_key)); return;&#125;它引入了0x0地址(缩写)上的LibraAccount模块，并调用rotate_authentication_key过程，替换账户身份验证密钥，这个与账户创建密钥不一样，这个密钥是用来创建交易签名的 下面这个示例是一个module + script，它以modules:开始，表明module的开始段落，以script开始事务脚本段落，事务脚本可以使用上面定义的module。 1234567891011121314151617181920212223242526272829303132modules:module B &#123; struct T &#123;g: u64&#125; public new(g: u64): V#Self.T &#123; return T&#123;g: move(g)&#125;; &#125; public t(this: &amp;V#Self.T) &#123; let g: &amp;u64; let y: u64; g = &amp;copy(this).g; y = *move(g); //这里因为this资源没有再次被使用，所以使用release减少一次引用计数 release(move(this)); return; &#125;&#125;script:import Transaction.B;main() &#123; let x: V#B.T; let y: &amp;V#B.T; x = B.new(5); y = &amp;x; B.t(move(y)); return;&#125; 接下来主要分析一下 LibraCoin 和LibraAccount这两个内置模块 LibraCoin 模块分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102module LibraCoin &#123; // A resource representing the Libra coin resource T &#123; // The value of the coin. May be zero value: u64, &#125; // A resource that grants access to `LibraCoin.mint`. Only the Association account has one. resource MintCapability &#123;&#125; // Return a reference to the MintCapability published under the sender&apos;s account. Fails if thesender does not have a MintCapability. // Since only the Association account has a mint capability, this will only succeed if it is invoked by a transaction sent by that account. public borrow_sender_mint_capability(): &amp;R#Self.MintCapability &#123; let sender: address; //可变引用 let capability_ref: &amp;mut R#Self.MintCapability; //不可变引用 let capability_immut_ref: &amp;R#Self.MintCapability; sender = get_txn_sender(); capability_ref = borrow_global&lt;MintCapability&gt;(move(sender)); //borrow_global默认返回可变引用，这里使用freeze需要去除可变性 capability_immut_ref = freeze(move(capability_ref)); return move(capability_immut_ref); &#125; // mint 一个新的LibraCoin.T资源价值 value, 调用者必须有一个MintCapability的引用 //只有联盟成员账户可以获取这样的引用，而且只能通过 borrow_sender_mint_capbaility方法获取 public mint(value: u64, capability: &amp;R#Self.MintCapability): R#Self.T &#123; release(move(capability)); return T&#123;value: move(value)&#125;; &#125; //这个过程是私有的，因为只能被虚拟机内部调用它只被使用 //在创世纪创建writeset时，为联盟帐户提供单个mintability grant_mint_capability() &#123; move_to_sender&lt;MintCapability&gt;(MintCapability&#123;&#125;); return; &#125; // Create a new LibraCoin.T with a value of 0 public zero(): R#Self.T &#123; return T&#123;value: 0&#125;; &#125; //公开coin数值的访问方法 public value(coin_ref: &amp;R#Self.T): u64 &#123; return *&amp;move(coin_ref).value; &#125; // 将 coin分为两半，一半是给定数值，一般是剩余数值 public split(coin: R#Self.T, amount: u64): R#Self.T * R#Self.T &#123; let other: R#Self.T; other = Self.withdraw(&amp;mut coin, move(amount)); return move(coin), move(other); &#125; //从给定coin资源中划分出amount数量的资源，并将新创建的资源返回 public withdraw(coin_ref: &amp;mut R#Self.T, amount: u64): R#Self.T &#123; let value: u64; // Check that `amount` is less than the coin&apos;s value value = *(&amp;mut copy(coin_ref).value); assert(copy(value) &gt;= copy(amount), 10); // 直接在原来的值上面分割 *(&amp;mut move(coin_ref).value) = move(value) - copy(amount); return T&#123;value: move(amount)&#125;; &#125; // 合并两个同样的coin资源，并将新的资源返回 public join(coin1: R#Self.T, coin2: R#Self.T): R#Self.T &#123; Self.deposit(&amp;mut coin1, move(coin2)); return move(coin1); &#125; // &quot;Merges&quot; the two coins check 是需要合并在coin_ref上的资源 public deposit(coin_ref: &amp;mut R#Self.T, check: R#Self.T) &#123; let value: u64; let check_value: u64; value = *(&amp;mut copy(coin_ref).value); T &#123; value: check_value &#125; = move(check); *(&amp;mut move(coin_ref).value)= move(value) + move(check_value); return; &#125; //销毁一个值为0的资源，不能销毁一个非0值的资源 public destroy_zero(coin: R#Self.T) &#123; let value: u64; T &#123; value &#125; = move(coin); assert(move(value) == 0, 11); return; &#125; //临时的程序，将来将会被取消，此程序主要是用来从账户消耗一定的手续费 public TODO_REMOVE_burn_gas_fee(coin: R#Self.T) &#123; let value: u64; T &#123; value &#125; = move(coin); return; &#125;&#125; LibraAccount模块分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302//这个模块主要是很对账户资源的，用于管理每个Libra账户//可以看到他引用了module LibraAccount &#123; import 0x0.LibraCoin; import 0x00.Hash; //每个Libra账户都有一个LibraAccount.T资源 // Every Libra account has a LibraLibraAccount.T resource resource T &#123; // The coins stored in this account balance: R#LibraCoin.T, //当前的身份认证key //这个key可以与创建账户的key不同 authentication_key: bytearray, //账户nonce sequence_number: u64, //临时的发送交易事件计数器，等到后面事件系统被完善后，这个值应该会被代替 sent_events_count: u64, //临时的交易接收事件计数器，等到后面事件系统被完善后，这个值应该会被代替 received_events_count: u64 &#125; // Message for sent events struct SentPaymentEvent &#123; // The address that was paid payee: address, // The amount of LibraCoin.T sent amount: u64, &#125; // Message for received events struct ReceivedPaymentEvent &#123; // The address that sent the coin payer: address, // The amount of LibraCoin.T received amount: u64, &#125; //创建一个新的LibraAccount.T类型的资源 //这个过程被内置模块create_account调用 make(auth_key: bytearray): R#Self.T &#123; let zero_balance: R#LibraCoin.T; zero_balance = LibraCoin.zero(); return T &#123; balance: move(zero_balance), authentication_key: move(auth_key), sequence_number: 0, sent_events_count: 0, received_events_count: 0, &#125;; &#125; // 向payee账户存入to_deposit资源 public deposit(payee: address, to_deposit: R#LibraCoin.T) &#123; let deposit_value: u64; let payee_account_ref: &amp;mut R#Self.T; let sender: address; let sender_account_ref: &amp;mut R#Self.T; let sent_event: V#Self.SentPaymentEvent; let received_event: V#Self.ReceivedPaymentEvent; // Check that the `to_deposit` coin is non-zero deposit_value = LibraCoin.value(&amp;to_deposit); assert(copy(deposit_value) &gt; 0, 7); // Load the sender&apos;s account sender = get_txn_sender(); sender_account_ref = borrow_global&lt;T&gt;(copy(sender)); // Log a send event sent_event = SentPaymentEvent &#123; payee: copy(payee), amount: copy(deposit_value) &#125;; // 目前的打印事件只是临时之举，未来应该会变得更加有条理 emit_event(&amp;mut move(sender_account_ref).sent_events_count, b&quot;73656E745F6576656E74735F636F756E74&quot;, move(sent_event)); // Load the payee&apos;s account payee_account_ref = borrow_global&lt;T&gt;(move(payee)); // Deposit the `to_deposit` coin LibraCoin.deposit(&amp;mut copy(payee_account_ref).balance, move(to_deposit)); // Log a received event received_event = ReceivedPaymentEvent &#123; payer: move(sender), amount: move(deposit_value) &#125;; // TEMPORARY The events system is being overhauled and this will be replaced by something // more principled in the future emit_event(&amp;mut move(payee_account_ref).received_events_count, b&quot;72656365697665645F6576656E74735F636F756E74&quot;, move(received_event)); return; &#125; //mint_to-address 只能被又有mint能力的的账户使用(参照LibraCoin模块) //这些帐户将被收取gas费用。如果这些帐户没有足够的gas支付,则mint失败 // 那些账户也可以mint给自己coin public mint_to_address(payee: address, amount: u64) &#123; let mint_capability_ref: &amp;R#LibraCoin.MintCapability; let coin: R#LibraCoin.T; let payee_account_ref: &amp;mut R#Self.T; let payee_exists: bool; let sender: address; // Mint the coin mint_capability_ref = LibraCoin.borrow_sender_mint_capability(); coin = LibraCoin.mint(copy(amount), move(mint_capability_ref)); // Create an account if it does not exist payee_exists = exists&lt;T&gt;(copy(payee)); if (!move(payee_exists)) &#123; //这一行感觉没必要 sender = get_txn_sender(); Self.create_new_account(copy(payee), 0); &#125; // Deposit the minted `coin` Self.deposit(move(payee), move(coin)); return; &#125; // Helper to withdraw `amount` from the given `account` and return the resulting LibraCoin.T withdraw_from_account(account: &amp;mut R#Self.T, amount: u64): R#LibraCoin.T &#123; let to_withdraw: R#LibraCoin.T; to_withdraw = LibraCoin.withdraw(&amp;mut move(account).balance, copy(amount)); return move(to_withdraw); &#125; // Withdraw `amount` LibraCoin.T from the transaction sender&apos;s account public withdraw_from_sender(amount: u64): R#LibraCoin.T &#123; let sender: address; let sender_account: &amp;mut R#Self.T; let to_withdraw: R#LibraCoin.T; // Load the sender sender = get_txn_sender(); sender_account = borrow_global&lt;T&gt;(move(sender)); // Withdraw the coin to_withdraw = Self.withdraw_from_account(move(sender_account), move(amount)); return move(to_withdraw); &#125; //从发送者账户转移资金到接受者，如果发送者账户不存在，先创建账户，然后再调用此过程 public pay_from_sender(payee: address, amount: u64) &#123; let to_pay: R#LibraCoin.T; let payee_exists: bool; payee_exists = exists&lt;T&gt;(copy(payee)); if (move(payee_exists)) &#123; to_pay = Self.withdraw_from_sender(move(amount)); Self.deposit(move(payee), move(to_pay)); &#125; else &#123; Self.create_new_account(move(payee), move(amount)); &#125; return; &#125; //更新交易发送者身份认证key //新的key将会被用于交易签名 public rotate_authentication_key(new_authentication_key: bytearray) &#123; let sender: address; let sender_account: &amp;mut R#Self.T; sender = get_txn_sender(); sender_account = borrow_global&lt;T&gt;(move(sender)); *(&amp;mut move(sender_account).authentication_key) = move(new_authentication_key); return; &#125; //创建一个新的账户，如果初始资金&gt;0，则从交易发送者账户转移资金到新账户 public create_new_account(fresh_address: address, initial_balance: u64) &#123; create_account(copy(fresh_address)); if (copy(initial_balance) &gt; 0) &#123; Self.pay_from_sender(move(fresh_address), move(initial_balance)); &#125; return; &#125; // Helper to return u64 value of the `balance` field for given `account` balance_for_account(account: &amp;R#Self.T): u64 &#123; let balance_value: u64; balance_value = LibraCoin.value(&amp;move(account).balance); return move(balance_value); &#125; // Return the current balance of the LibraCoin.T in LibraLibraAccount.T at `addr` public balance(addr: address): u64 &#123; let payee_account: &amp;mut R#Self.T; let imm_payee_account: &amp;R#Self.T; let balance_amount: u64; //从账户地址，拿到LibraAccount类型的资源，此时拿到的资源是可变的 payee_account = borrow_global&lt;T&gt;(move(addr)); //将资源转为不可变资源，防止误操作 imm_payee_account = freeze(move(payee_account)); balance_amount = Self.balance_for_account(move(imm_payee_account)); return move(balance_amount); &#125; // Helper to return the sequence number field for given `account` sequence_number_for_account(account: &amp;R#Self.T): u64 &#123; return *(&amp;move(account).sequence_number); &#125; // Return the current sequence number at `addr` public sequence_number(addr: address): u64 &#123; let account_ref: &amp;mut R#Self.T; let imm_ref: &amp;R#Self.T; let sequence_number_value: u64; account_ref = borrow_global&lt;T&gt;(move(addr)); imm_ref = freeze(move(account_ref)); sequence_number_value = Self.sequence_number_for_account(move(imm_ref)); return move(sequence_number_value); &#125; // Checks if an account exists at `check_addr` public exists(check_addr: address): bool &#123; let is_present: bool; is_present = exists&lt;T&gt;(move(check_addr)); return move(is_present); &#125; // 序言过程在每笔交易开始的时候被调用，它要做以下验证： //账户的身份key是否匹配交易的公钥 //账户是否有足够的金额支付所有的gas //sequence number是否匹配当前账户sequence key prologue() &#123; let transaction_sender: address; let transaction_sender_exists: bool; let sender_account: &amp;mut R#Self.T; let imm_sender_account: &amp;R#Self.T; let sender_public_key: bytearray; let public_key_hash: bytearray; let gas_price: u64; let gas_units: u64; let gas_fee: u64; let balance_amount: u64; let sequence_number_value: u64; let transaction_sequence_number_value: u64; transaction_sender = get_txn_sender(); // 现在这些error code还是很不友好的，后续应该会变得更好 transaction_sender_exists = exists&lt;T&gt;(copy(transaction_sender)); assert(move(transaction_sender_exists), 5); // Load the transaction sender&apos;s account sender_account = borrow_global&lt;T&gt;(copy(transaction_sender)); //检查交易的公钥是否与当前账户的身份key相匹配 sender_public_key = get_txn_public_key(); public_key_hash = Hash.sha3_256(move(sender_public_key)); assert(move(public_key_hash) == *(&amp;copy(sender_account).authentication_key), 2); // 检查是否有足够的余额支付交易手续费 gas_price = get_txn_gas_unit_price(); gas_units = get_txn_max_gas_units(); //先计算最大所需的手续费,在交易结束后进行扣除真实消耗的gas手续费 gas_fee = move(gas_price) * move(gas_units); imm_sender_account = freeze(copy(sender_account)); balance_amount = Self.balance_for_account(move(imm_sender_account)); assert(move(balance_amount) &gt;= move(gas_fee), 6); // 检查交易的sequence number是否与账户保存的sequence number匹配 sequence_number_value = *(&amp;mut move(sender_account).sequence_number); transaction_sequence_number_value = get_txn_sequence_number(); //这里多判断一次可能是未来防止并行交易的时候较大sequence number可以被接受 assert(copy(transaction_sequence_number_value) &gt;= copy(sequence_number_value), 3); assert(move(transaction_sequence_number_value) == move(sequence_number_value), 4); return; &#125; // 收尾主要是被用于在交易结束后进行一些处理 //主要是计算交易真实消耗gas的手续费和调整账户sequence number // The epilogue is invoked at the end of transactions. // It collects gas and bumps the sequence number epilogue() &#123; let transaction_sender: address; let sender_account: &amp;mut R#Self.T; let imm_sender_account: &amp;R#Self.T; let gas_price: u64; let gas_units_remaining: u64; let starting_gas_units: u64; let gas_fee_amount: u64; let balance_amount: u64; let gas_fee: R#LibraCoin.T; let transaction_sequence_number_value: u64; transaction_sender = get_txn_sender(); // Load the transaction sender&apos;s account sender_account = borrow_global&lt;T&gt;(copy(transaction_sender)); //收取真实消耗的gas的手续费 gas_price = get_txn_gas_unit_price(); starting_gas_units = get_txn_max_gas_units(); gas_units_remaining = get_gas_remaining(); gas_fee_amount = move(gas_price) * (move(starting_gas_units) - move(gas_units_remaining)); imm_sender_account = freeze(copy(sender_account)); balance_amount = Self.balance_for_account(move(imm_sender_account)); assert(move(balance_amount) &gt;= copy(gas_fee_amount), 6); gas_fee = Self.withdraw_from_account(copy(sender_account), move(gas_fee_amount)); //销毁掉相应的手续费资源 LibraCoin.TODO_REMOVE_burn_gas_fee(move(gas_fee)); // 账户sequence number + 1 transaction_sequence_number_value = get_txn_sequence_number(); *(&amp;mut move(sender_account).sequence_number) = move(transaction_sequence_number_value) + 1; return; &#125;&#125;]]></content>
      <categories>
        <category>libra</category>
        <category>move语言</category>
      </categories>
      <tags>
        <tag>libra</tag>
        <tag>move语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Move:一种可编程资源语言]]></title>
    <url>%2F2019%2F07%2F10%2Flibra-move-paper%2F</url>
    <content type="text"><![CDATA[Move:一种可编程资源语言Abstract. 我们为Libra区块链提供了一种安全灵活的编程语言Move， Move是一种可执行的字节码语言，用于实现自定义事务和智能合约。Move的关键特性是能够使用受linear启发的语义定义自定义资源类型。资源永远不能被复制或者被隐式丢弃，只能在程序的存储位置间移动。这些安全保证由Move的类型系统静态执行，尽管有这些特殊保护，资源仍然是一种普通的程序值，它们可以存储在数据结构中作为参数传递给处理逻辑，等等。资源优先是一种很普遍的观念。程序员不仅可以实现安全的数字资产，还可以编写正确的业务用于包装资产和强制访问控制策略的逻辑。Move的安全性和表达性使我们能够在Move中实现Libra协议的重要部分，包括Libra Coin，事务处理和验证器管理. 介绍互联网和移动宽带的出现连接了全球数十亿人，为他们提供了获取知识、免费通信以及一系列更低成本、更便捷的服务。这种互联互通也使更多的人能够进入金融生态系统。然而，尽管取得了这些进展，对那些最需要金融服务的人来说，获得金融服务的机会仍然有限。 Libra的任务是改变这种状况。在本文中，我们提出了一种新的编程语言Move，用于在Libra协议中实现自定义事务逻辑和智能合约。为介绍Move，我们: 描述在区块链上表示数字资产的挑战 (第二节). 解释我们的Move设计如何解决这些挑战 (第三节). 给出一个样例用以概述Move的主要特性和编程模型 (第四节). 深入研究语言和虚拟机设计的技术细节 (第五节, 第六节,和附录A). 最后，总结一下我们在Move方面取得的进展，描述我们的语言发展计划，并概述我们在Libra区块链上支持第三方Move代码的路线图 观众 本文针对两种不同的受众群体: 不熟悉区块链系统的编程语言研究人员。我们鼓励这些读者从头到尾阅读这篇文章，但是我们警告说，我们有时可能在没有为不熟悉的读者提供足够上下文的情况下引用区块链概念。 区块链开发人员可能不熟悉编程语言的研究，但有兴趣学习移动语言。我们鼓励观众从这里开始(第三节)。我们注意，第5、第6部分和附录A中包含一些编程语言术语和形式化，这些术语和形式化可能是不熟悉的。 在区块链上管理数字资产我们将从抽象层次简要解释区块链开始，以帮助读者理解像Move这样的“区块链编程语言”所扮演的角色。本讨论有意省略了区块链系统的许多重要细节，以便集中讨论与语言角度相关的特性。 区块链的抽象视图区块链是一个复制状态机。系统中的复制器称为验证器。系统用户向验证器发送事务。每个验证器都了解如何执行事务，以便将其内部状态机从当前状态转换到新状态. 验证器利用它们对事务执行的共享理解，遵循一致协议来集体定义和维护复制状态。如果 验证器从相同的初始状态开始， 验证器就下一个事务应该是什么达成一致, 验证器会产生确定的状态转换 然后验证器还将对下一个状态达成一致。反复应用此方案允许验证器处理事务，同时继续就当前状态达成一致。 注意，协商一致协议和状态转换组件对彼此的实现细节并不敏感。只要协商一致协议确保事务之间的总顺序和状态转换方案是确定的，组件就可以和谐地交互。 在开放系统中编码数字资产像Move这样的区块链编程语言的作用是决定如何表示转换和状态。为了支持丰富的金融基础设施，Libra的区块链状态必须能够在给定的时间点对数字资产的所有者进行编码。此外，状态转换应该允许资产的转移。 在区块链编程语言的设计中必须考虑另一个因素。与其他公共区块链一样，Libra区块链是一个开放的系统,任何人都可以查看当前的区块链状态或将事务提交给验证器(即，建议状态转换)。传统上，管理数字资产的软件(如银行软件)是在一个封闭的系统中运行的，具有特殊管理控制.所有参与者地位平等。参与者可以提出任何她喜欢的状态转换，但是系统不应该允许所有的状态转换。例如，Alice可以自由地提出一个转移Bob拥有的资产的状态转换。状态转换函数必须能够识别此状态转换无效并拒绝它. 在一个开放的软件系统中，选择转换和状态的表示形式来编码数字资产的所有权是很有挑战性的。特别是，物理资产有两个属性很难在数字资产中编码 稀缺性。应该控制系统中的资产供应。应该禁止复制现有资产，创建新资产应该是一项特权操作。 访问控制.系统的参与者应该能够通过访问策略保护来访问她的资产 为了直观的表示，我们将看到这些问题是如何在表示状态转换的一系列strawman原型中出现的。我们将假设区块链跟踪一个称为StrawCoin的数字资产，区块链状态G结构为映射用户标识的键值存储(用加密公钥表示)到自然数值，自然数值编码每个用户持有的稻草币提案由一个事务脚本组成，该脚本将使用给定的评估规则进行评估，生成一个应用于全局状态的更新。我们将编写G[𝐾]:=𝑛 表示存储在密钥𝐾在全球区块链状态的价值为n。 每个提案的目标都是设计一个足够有表现力的系统，使Alice能够发送StrawCoin到Bob，但其限制足以防止任何用户违反稀缺性或访问控制属性。这些提议并不试图解决诸如重放攻击之类的安全问题，这些问题很重要，但与我们讨论的稀缺性和访问控制无关。 稀缺性。 最简单的建议是直接将更新编码到事务脚本中的状态 这个表示可以编码将StrawCoin从Alice发送到Bob。但它有几个严重的问题。首先，这一提议并没有强化StrawCoin的稀缺性。Alice能给尽可能多的StrawCoin她高兴“凭空”通过发送事务⟨Alice,100⟩。因此，Alice发送给Bob的StrawCoin实际上是没有价值的，因为Bob也可以很容易地为自己创建这些Coin. 稀缺性是有价值实物资产的重要属性。像黄金这样的稀有金属自然是稀缺的，但数字资产并不存在固有的物理稀缺。以字节序列编码的数字资产，如G[Alice]→10，在物理上并不比另一个字节序列(如G[Alice]→100)更难生成或复制。相反，评估规则必须以编程方式实施稀缺性。 让我们考虑第二个考虑到稀缺性的提议: 在这个方案下,事务脚本指定的公钥𝐾𝑎发件人,Alice,和公钥𝐾𝑏接收者 Bob。评价规则现在检查的数量StrawCoin储存在𝐾𝑎至少𝑛之前执行任何更新。如果检查成功,评价规则减去从StrawCoin 𝑛 储存在发送方的密钥和 𝑛补充到储存在收件人钥匙下的StrawCoin。在此方案下，执行一个有效的事务脚本通过保存系统中的StrawCoin数量来强制执行稀缺性。Alice不能再创造了，他只能从账户中给Bob StrawCoin。 访问控制。 尽管第二项提案解决了资源稀缺的问题，但它仍然存在一个问题:Bob可以发送使用属于Alice的稻草币的交易。例如,没有评价规则将阻止Bob发送事务⟨Alice,100,Bob⟩。我们可以通过添加基于数字签名的访问控制机制来解决这个问题: 这个方案要求Alice用她的私钥签署事务脚本。我们写𝑆𝐾(𝑚)签署消息𝑚使用私钥与公钥𝐾配对。评价规则使用verify_sig函数对Alice的检查签名公钥𝐾𝑎。如果没有验证签名，则不执行更新。这个新规则通过使用数字签名的不可伪造性来防止Alice从她自己的账户以外的任何账户借记StrawCoin，从而解决了之前提议的问题. 另外，请注意，在第一个strawman原型中实际上不需要评估规则——提议的状态更新直接应用于键值存储。但是，随着我们对这些建议的深入研究，在执行更新的先决条件和更新本身之间出现了明显的分离,评估规则通过评估脚本来决定是否执行更新以及执行什么更新。这种分离是基本的，因为执行访问控制和稀缺性策略不可避免地需要某种形式的评估——用户提出状态更改必须执行计算以确定状态更改是否符合策略。在一个开放的系统中，不能信任参与者执行策略并向状态提交直接更新(如第一个建议中所述)。相反，访问控制策略必须由评估规则在链上强制执行. 现有的区块链语言StrawCoin是一种玩具语言，但它试图捕捉比特币脚本的本质和和Ethereum虚拟机字节码语言(尤其是后者)。虽然这些语言比StrawCoin更复杂，但它们面临许多相同的问题: 资产的间接表示。资产使用整数编码，但整数值与资产不同。实际上，没有表示的类型或值在 Bitcoin/Ether/ StrawCoin 中， 这使得编写使用资产的程序变得非常困难，并且容易出错。诸如将资产传入/传出过程或将资产存储在数据结构中的模式需要特殊的语言支持。 稀缺性是不可扩展的。语言只代表一种稀缺资产。此外，稀缺性保护直接硬编码在语言语义中。希望创建自定义资产的程序员必须在没有语言支持的情况下仔细地重新实现稀缺性。 访问控制不灵活。模型执行的唯一访问控制策略是基于公钥的签名方案。与稀缺性保护一样，访问控制策略也深深地嵌入到语言语义中。如何扩展该语言以允许程序员定义自定义访问控制策略并不明显。 Bitcoin Script 。 Bitcoin Script有一个简单而优雅的设计，专注于表示用于消费比特币的自定义访问控制策略。全局状态由一组未使用的事务输出(UTXOs)组成。比特币脚本程序提供的输入(例如数字签名)满足它所使用的旧UTXOs的访问控制策略，并为它创建的新UTXOs指定定制的访问控制策略。由于比特币脚本包含强大的数字签名检查指令(包括多签名支持)，程序员可以编码多种访问控制。 然而比特币脚本的表达能力从根本上是有限的。程序员不能定义自定义数据类型(因此也不能定义自定义资产)或过程，而且语言也不完整。合作各方可以通过复杂的多事务协议或通过“彩色硬币”非正式地定义自定义资产来执行更丰富的计算。然而，这些方案的工作原理是将复杂性推到语言之外，因此不支持真正的可扩展性。 Ethereum Virtual Machine bytecode 。 Ethereum是一个开创性的系统，演示了如何使用区块链系统不仅仅用于支付。Ethereum虚拟机(EVM)字节码程序员可以发布与ether之类的资产交互的智能合约，并使用图灵完备语言定义新资产。EVM支持比特币脚本所不能支持的东西，例如用户定义的过程、虚拟调用、循环和数据结构。 然而，EVM的的表现为代价高昂的编程错误打开了大门。就像StrawCoin是一种ether货币，在语言中具有特殊的地位，它的实现方式强调了稀缺性,但是定制资产的实现者(例如，通过ERC20标准)不继承这些保护(如第(2)所述)-他们必须小心不要引入允许复制、重用或丢失资产的bug。这是具有挑战性的，因为结合了间接表示问题中描述,以及EVM的高度动态行为。特别是，将ether转移到智能合约涉及到动态分派，这导致了一类新的bug，称为可重入性漏洞。引人注目的漏洞，如DAO攻击和Parity Wallet攻击，已经允许攻击者窃取价值数百万美元的加密货币。 Move设计目标Libra的使命是使一个简单的全球货币和金融基础设施，使数十亿人的受益。Move语言的设计目的是提供一个安全的、可编程的基础，在此基础上可以构建这个愿景。Move必须能够以精确、可理解和可验证的方式表达Libra的货币和治理规则。从长远来看，Move必须能够编码构成金融基础设施的丰富多样的资产和相应的业务逻辑。 为了满足这些需求，我们设计Move时考虑了四个关键目标:头等资产、灵活性、安全性和可验证性 资源是头等公民区块链系统允许用户编写与数字资产直接交互的程序。正如我们在第2.2节中讨论的，数字资产具有特殊的特性，这些特性将它们与传统编程中使用的值(如布尔值、整数和字符串)区分开来。使用资产进行编程的健壮而优雅的方法需要保持这些特征的表示形式。 Move的关键特性是能够使用线性逻辑激发的语义定义自定义资源类型:资源永远不能复制或隐式丢弃，只能在程序存储位置之间移动。这些安全保证由Move的类型系统静态执行。尽管有这些特殊的保护，资源仍然是普通的程序值——它们可以存储在数据结构中，作为参数传递给过程，等等。资源放在第一位置是一个非常普遍的概念，程序员不仅可以使用它来实现安全的数字资产，还可以用它来编写正确的业务逻辑来包装资产和执行访问控制策略。 Libra coin本身就是一种普通的Move资源，在语言中没有特殊的地位。由于Libra coin代表Libra 储备管理的真实世界资产，因此Move必须允许创建资源(例如，当新的真实世界资产进入Libra储备时)、修改(例如，当数字资产更改所有权时)和销毁(例如，当支持数字资产的物理资产被出售时)。Move程序员可以使用模块保护对这些关键操作的访问。Move模块类似于其他区块链语言中的智能合约。模块声明资源类型和过程，这些类型和过程编码用于创建、销毁和更新其声明的资源的规则。模块可以调用其他模块声明的过程并使用其他模块声明的类型。然而，模块强制执行强数据抽象——类型在其声明模块内部是透明的，而在其外部是不透明的。此外，对资源类型T的关键操作只能在定义T的模块中执行。 灵活性Move通过事务脚本为Libra增加了灵活性。每个Libra事务都包含一个事务脚本，该脚本实际上是事务的主要过程。事务脚本是一个包含任意移动代码的过程，允许定制事务。一个脚本可以调用发布在区块链中的多个模块的过程，并对结果执行本地计算。这意味着脚本可以执行表达性的一次性行为(例如向一组特定的接收者付费)或可重用行为(通过调用封装可重用逻辑的单个过程)。 通过安全而灵活的代码组合，Move模块提供了一种不同的灵活性。在高层次上，Move中modules/resources/procedures 之间的关系类似于面向对象编程中的类/对象/方法之间的关系。然而，有一些重要的区别——一个Move模块可以声明多个资源类型(或零资源类型)，而Move过程没有self或这个值的概念。Move模块与ml风格的模块的限定版本最为相似。 安全性Move必须拒绝不满足关键属性(如资源安全性、类型安全性和内存安全性)的程序。我们如何选择一个可执行的表示，以确保每一个在区块链上执行的程序满足这些性质?两种可能的方法是:(a)使用带有检查这些属性的编译器的高级编程语言，或者(b)使用低级非类型化程序集并在运行时执行这些安全检查。Move采取的方法介于这两个极端之间。Move的可执行格式是一种类型字节码，它比assembly级别高，但比source language 级别低。在链上检查资源、类型和内存安全性，然后由字节码解释器直接执行。此选项允许Move提供通常与源语言关联的安全保证，但不需要将源编译器添加到可信计算基础中，也不需要将编译成本添加到事务执行的关键路径中。 可验证性理想情况下，我们将通过链上字节码分析或运行时检查检查Move程序的每个安全属性。不幸的是，这是不可行的。我们必须仔细权衡安全保证的重要性和通用性，以及使用链上验证来执行安全保证的计算成本和增加的协议复杂性。 我们的方法是尽可能多地执行关键安全特性的轻量级链上验证，但是设计Move语言来支持高级的离线静态验证工具。我们做了几个设计决定，使得Move比大多数通用语言更适合静态验证: 没有动态调用。可以静态地确定每个调用站点的目标。这使得验证工具可以很容易地精确地推断过程调用的效果，而无需执行复杂的调用图构造分析。 有限的可变性。 对Move值的每个突变都是通过引用发生的,引用是必须在单个事务脚本的范围内创建和销毁的临时值。Move的字节码验证器使用类似于Rust的“借用检查”方案，以确保在任何时间点最多存在一个对值的可变引用。此外，该语言确保全局存储始终是树而不是任意图。这允许验证工具模块化有关写操作效果的推理。 模块化 。 Move模块执行数据抽象并本地化资源上的关键操作。模块启用的封装与Move类型系统强制实施的保护相结合，确保为模块类型建立的属性不会被模块外部的代码违反。我们希望通过这种设计，可以在不考虑其客户机的情况下单独查看模块，从而对重要的模块不变量进行详尽的功能验证。 静态验证工具可以利用Move的这些属性来准确有效地检查运行时是否没有出现故障(例如整数溢出)，以及重要的特定于程序的功能正确性属性(例如，锁定在支付通道中的资源最终可以由参与者声明)。我们将在第7节中分享关于功能验证计划的更多细节。 Move概述我们将介绍Move的基础知识，方法是遍历简单对等支付中涉及的事务脚本和模块。该模块是实际Libra Coin实现的简化版本。示例事务脚本演示了模块外部恶意或粗心的程序员不能违反模块资源的关键安全不变量。示例模块展示了如何实现一个利用强大的数据抽象来建立和维护这些不变量的资源。 本节中的代码片段是用Move中间代码(IR)编写的。Move IR的级别足够高，可以编写人类可读的代码，但又足够低，可以直接转换来Move字节码。我们提供 Move IR代码，因为基于堆栈的Move字节码更难以读取，而且我们目前正在设计一种Move源代码语言(请参阅第七节）我们注意到，在执行代码之前，Move类型系统提供的所有安全保证都在字节码级别进行检查。 点对点支付交易脚本 此脚本接受两个输入:付款接收方的帐户地址和表示要转移到接收方的Coin数量的无符号整数。执行此脚本的效果很简单: amount数量的Coin将从sender转移到payee。这需要两个步骤。在第一步中，发送方从存储在0x0.Currency的模块调用一个名为抽出withdraw_from_sender的过程 ,正如我们将在第4.2节中解释的那样, 0x0是存储在模块里的帐户地址，Currency是模块的名称。这个过程返回的值coin是一个资源值，其类型为0x0.Currency.Coin ,在第二步中，发送方通过将coin资源值移动到0x0.Currency 的 deposit过程， 将资金转移到payee。 这个例子很有趣，因为它非常微妙。Move的类型系统将拒绝相同代码中可能导致不良行为的小变体。特别是，类型系统确保资源永远不会被复制、重用或丢失。例如，类型系统会拒绝以下三个对脚本的更改: 通过改变 move(coin) to copy(coin)来复制货币。 注意，示例中变量的每次使用都被包装在copy()或move()中。 继Rust和c++之后，Move实现了Move语义。每次读取移动变量x时，必须指定使用是将x的值移出该变量(使x不可用)，还是复制该值(使x可继续使用)。无限制的值类似u64 和 address 既可以被move 也可以被copy。 但是资源值只能被 move，试图copy资源值(例如，在上面的例子中使用copy(coin))将在字节码验证时导致错误。 通过两次编写move(coin)来重用货币 添加 0x0.Currency.deposit(copy(some_other_payee), move(coin))这一行在以上的例子会让投币人“花”两次Coin，第一次花在收款人身上，第二次花在其他收款人身上。这种不受欢迎的行为对于物理资产是不可能的， 幸运的是，此举将被拒绝。变量coin在第一次移动后不可用，第二次移动将触发一个字节码验证错误。 忘记move(coin)而丢失货币 。 Move语言实现了线性的资源，这些资源必须被精确地移动一次。未能move资源(例如，删除上面示例中包含move(coin)的行)将触发字节码验证错误。这可以防止程序员意外地(或有意地)丢失对资源的跟踪。这些担保超出了纸币等实物资产所能提供的范围。 我们使用“资源安全”这个术语来描述移动资源永远不会被复制、重用或丢失的保证。这些保证非常强大，因为Move程序员可以实现同样享受这些保护的自定义资源。正如我们在3.1节中提到的，即使是Libra货币也被实现为自定义资源，在Move语言中没有特殊的地位。 Currency模块在本节中，我们将展示上面示例中使用的Currency模块的实现如何利用资源安全性来实现安全的可替换资产。我们将首先解释一下运行move代码的区块链环境 入门： Move执行模型 正如我们在第3.2节中解释的，Move有两种不同的程序:事务脚本(如第4.1节中概述的示例)和模块(如货币模块，我们很快就会讲到 类似于示例的事务脚本包含在每个用户提交的事务和模块的调用过程中，以更新全局状态。执行事务脚本是全有或全无的——要么执行成功完成，脚本执行的所有写操作都提交到全局存储，要么执行终止时出现错误(例如，由于断言失败或耗尽gas错误)，什么也不提交。事务脚本是一段一次性使用的代码——在执行之后，其他事务脚本或模块不能再次调用它。 相反，模块是一段以全局状态发布的长生命周期代码。模块名称0x0.Currency。上面示例中使用的货币包含发布模块代码的帐户地址0x0。全局状态结构为从帐户地址到帐户的映射。 每个帐户可以包含0个或多个模块(以矩形表示)和一个或多个资源值(以柱面表示)。 例如，地址0x0处的帐户包含一个模块0x0.Currency和类型0x0.Currency.Coin的资源值。地址0x1的账户有两个资源和一个模块;地址为0x2的帐户有两个模块和一个资源值。 帐户最多可以包含一个给定类型的资源值，最多可以包含一个具有给定名称的模块。地址0x0处的帐户将不允许包含额外的0x0. Currency.Coin 或者其他叫做Currency的模块。但是，地址0x1的帐户可以添加一个名为Currency的模块。在这种情况下，0x0也可以保存0x1.Currency.Coin类型的资源。0x0.currency.coin和0 x1.currency.coin是不同的类型，不能互换使用;声明模块的地址是类型的一部分 注意，在帐户中最多允许给定类型的单一资源并不受限制。此设计为顶级帐户值提供了一个可预测的存储模式。程序员仍然可以通过定义自定义包装器资源(例如，资源TwoCoins {c1: 0x0.Currency.Coin, c2: 0x0.currency.Coin}) 声明Coin资源。在解释了模块如何适合于Move执行模型之后，我们终于准备好查看货币Currency模块内部了 此代码声明一个名为Currency的模块和一个由模块管理的名为Coin的资源类型。Coin是一种Struct类型，其单个字段值类型为u64(64位无符号整数)。Coin的结构在货币模块之外是不透明的。其他模块和事务脚本只能通过模块公开的公共过程编写或引用value字段。同样，只有Currency模块的过程才能创建或销毁类型Coin的值。此方案支持强数据抽象——模块作者可以完全控制其声明资源的访问、创建和销毁。在货币模块公开的API之外，其他模块只能对硬币执行移动操作。资源安全性禁止其他模块复制、销毁或重复移动资源。 Implementing deposit 。让我们研究一下前面小节中的事务脚本调用的Currency.deposit过程是如何工作的 在较高的级别上，此过程以Coin资源作为输入，并将其与存储在收款人帐户中的Coin资源相结合。它通过: 销毁输入硬币并记录其价值 获取对收款人帐户下存储的唯一Coin资源的引用 将收款人的Coin的价值与传递给程序的Coin的价值相加 这个过程的底层机制有一些方面值得解释。绑定到to_deposit的Coin资源由存款程序拥有。要调用该过程，调用者需要将绑定到to_deposit的硬币移动到被调用者中(这将防止调用者重用它) 第一行调用的Unpack过程是用于操作模块声明的类型的几个模块内置程序之一,Unpack&lt;T&gt; 是删除一个资源类型T的唯一方式。它接受类型为T的资源作为输入，销毁它，并返回绑定到资源字段的值。像Unpack这样的模块内建只能用于当前模块中声明的资源。在Unpack的情况下，此约束可防止其他代码破坏Coin，从而允许Currency模块设置自定义的销毁Coin资源的前提条件(例如，它只能选择允许销毁零值钱币) 第三行调用的BorrowGlobal过程也是一个模块构建，BorrowGlobal&lt;T&gt;将一个地址作为输入，并返回对在该地址下发布的T的惟一实例的引用。 这意味着上面代码中的coin_ref类型是&amp;mut Coin 对Coin资源的可变引用,这不是Coin-这是一个拥有的Coin资源。下一行将引用值绑定到coin_ref，以便获得指向硬币值字段的coin_value_ref引用。程序的最后几行读取收款人Coin资源的前一个值，并修改coin_value_ref以反映存款金额 我们注意到，Move类型系统不能捕获模块中所有的实现错误。例如，类型系统不会确保所有现存Coin的总价值都通过存款通知来保存, 如果程序员写错了*move(coin_value_ref) = 1 + move(coin_value) + move(to_deposit_value)在最后一行，类型系统将毫无疑问地接受代码,这就明确了职责划分:在模块内部为Coin建立合适的安全不变量是程序员的工作，确保模块外部的Coin客户端不能违反这些不变量是类型系统的工作。 Implementing withdraw_from_sender。 在上述实现中，通过存款程序存入资金不需要任何授权——任何人都可以调用存款。相反，从帐户中取款必须受到访问控制策略的保护，该策略向货币资源的所有者授予独占特权。让我们看看由对等支付事务脚本调用的抽出withdraw_from_sender过程如何实现此授权 这个过程几乎与存款相反，但也不完全相反。它: 获取对发送方帐户下发布的Coin类型的惟一资源的引用 将referenced Coin 的值减去输入量 创建并返回一个带有value amount的新Coin资源 这个过程执行的访问控制检查有点微妙。deposit过程允许调用者指定传递给BorrowGlobal的地址，但是withdraw_from_sender只能传递GetTxnSenderAddress返回的地址，此过程是几个内置事务之一，允许Move代码从当前正在执行的事务中读取数据。Move virtual machine在执行事务之前对发送方地址进行身份验证。使用借用全局内置函数以这种方式确保交易的发送方只能从自己的Coin资源中提取资金。 与所有内置模块一样，BorrowGlobal&lt;Coin&gt;只能在声明的模块中调用Coin。如果Currency模块没有公开一个返回BorrowGlobal结果的过程，则Currency模块之外的代码无法获得对全局存储中发布的Coin资源的引用。 在降低事务发送方的Coin资源的值之前，该过程断言硬币的值大于或等于使用RejectUnless指令输入的正式金额。这可以确保发送者不能取比她多的钱。如果该检查失败，当前事务脚本的执行将停止，它执行的任何操作都不会应用到全局状态。 最后，该过程按数量减少发送方硬币的价值，并使用Pack(Pack module builtin)创建一个新的Coin资源。Pack&lt;T&gt;创建了一个T类型的新资源，就像Unpack&lt;T&gt;一样，Pack&lt;T&gt;只能在资源T的声明模块中调用。在这里，Pack用于创建一个类型为Coin的资源new_coin并将其移动到调用方。调用者现在拥有这个Coin资源，可以将它移动到任何她喜欢的地方。在第4.1节的示例事务脚本中，调用者选择将Coin存入收款人的帐户。 Move语言在本节中，我们将介绍Move语言、字节码验证器和虚拟机的半形式化描述。附录A详细地列出了所有这些组件，但没有附带任何文字。我们这里的讨论将使用附录中的摘录，并偶尔引用其中定义的符号。 Move的目标是使程序员能够定义全局区块链状态，并安全地实现更新全局状态的操作。正如我们在第4.2节中所解释的，全局状态被组织为从地址到帐户的部分映射。帐户同时包含资源数据值和模块代码值。帐户中的不同资源必须具有不同的标识符。帐户中的不同模块必须有不同的名称。 模块由名称、结构声明(包括资源，稍后我们将解释)和程序声明。代码可以使用由模块的帐户地址和模块名称组成的唯一标识符引用已发布的模块。模块标识符充当一个命名空间，它限定模块外部代码的结构类型和过程的标识符。Move模块支持强大的数据抽象。模块的过程编码用于创建、编写和销毁模块声明的类型的规则。类型在其声明模块内部是透明的，在外部是不透明的。Move模块还可以通过MoveToSender指令强制发布帐户下的资源的先决条件，通过BorrowGlobal指令获取对帐户下资源的引用，并通过MoveFrom指令从帐户中删除资源。 模块使Move程序员能够灵活地为资源定义丰富的访问控制策略。例如，模块可以定义一个只能在f字段为零时销毁的资源类型，或者一个只能在特定帐户地址下发布的资源。 Move支持基本类型，包括布尔值、64位无符号整数、256位帐户地址和固定大小的字节数组。struct是由模块声明的用户定义类型。通过用资源类型标记结构类型，可以将其指定为资源。所有其他类型，包括非资源结构类型和基本类型，都称为无限制类型。 资源类型的变量是资源变量;无约束类型的变量是无约束变量。字节码验证器对资源类型的资源变量和结构字段施加限制，资源变量不能复制，必须始终移动。资源变量和资源类型的struct字段都不能重新分配——这样做会破坏先前保存在存储位置中的资源值。此外，对资源类型的引用不能取消引用，因为这将生成基础资源的副本。相反，不受限制的类型可以复制、重新分配和取消引用。 最后，不受限制的结构类型可能不包含具有资源类型的字段。此限制确保(a)复制无限制结构不会导致复制嵌套资源，(b)重新分配无限制结构不会导致销毁嵌套资源。 引用类型可以是可变的，也可以是不可变的;不允许通过不可变引用进行写操作。字节码验证器执行引用安全检查，执行这些规则以及对资源类型的限制(参见5.2节)。 除了结构和基本值之外，Move还支持引用值。引用与其他移动值不同，因为它们是瞬态的。字节码验证器不允许引用类型的字段。这意味着必须在事务脚本执行期间创建引用，并在事务脚本结束之前释放引用。 对struct值形状的限制确保全局状态始终是树而不是任意图，状态树中的每个存储位置可以使用其正规的代表访问路径——一个存储树中的路径从一个根(一个局部变量𝑥或全球资源关键𝑔)到后代节点被字段标识符𝑓序列标记。 该语言允许对原始值和结构的引用，但不允许对其他引用的引用。Move程序员可以使用BorrowLoc指令获取对本地变量的引用，使用BorrowField指令获取对结构的字段的引用，以及使用BorrowGlobal指令。后两种构造只能用于当前模块中声明的结构类型。 过程签名由可见性、类型化形式参数和返回类型组成。过程声明包含签名、类型化局部变量和字节码指令数组。过程可见性可以是公开的，也可以是内部的。内部过程只能由同一模块中的其他过程调用。任何模块或事务脚本都可以调用公共过程。 区块链状态由一个事务脚本更新，该脚本可以调用当前发布在帐户下的任何模块的公共过程。事务脚本只是一个没有关联模块的过程声明。 一个过程可以由它的模块标识符和它的签名唯一地标识。调用字节码指令需要一个惟一的过程ID作为输入。这确保了Move中的所有过程调用都是静态确定的——没有函数指针或虚拟调用。此外，模块之间的依赖关系通过构造是非循环的。模块只能依赖于线性事务历史中较早发布的模块。无循环模块依赖关系图和缺乏动态分派的组合强制执行一个强执行不变量:属于模块中的过程的所有堆栈帧必须是连续的。因此，在Move模块中没有与Ethereum智能合约的可重入性问题等价的问题。 在本节的其余部分中，我们将介绍字节码操作及其语义(第5.1节)，并描述字节码验证器在允许执行或存储模块代码之前执行的静态分析(第5.2节)。 字节码解释器 Move字节码指令由基于堆栈的解释器执行，类似于公共语言运行时和Java虚拟机。一条指令从堆栈中使用操作数并将结果推入堆栈。指令也可以从当前过程的局部变量(包括形式参数)中移动和复制值。 字节码解释器支持过程调用。传递给被调用方的输入值和返回给调用方的输出值也通过堆栈进行通信。首先，调用者将参数推送到堆栈上的过程。接下来，调用者调用Call指令，该指令为被调用者创建一个新的调用堆栈帧，并将推入的值加载到被调用者的本地变量中。最后，字节码解释器开始执行被调用过程的字节码指令。 字节码的执行通过按顺序执行操作来进行，除非有分支操作导致跳转到当前过程中静态确定的偏移量。当被调用方希望返回时，它将返回值推入堆栈并调用Return指令。控制返回给调用者，调用者将查找堆栈上的输出值。 Move程序的执行以类似EVM的方式进行计量。每个字节码指令都有一个相关的gas单位成本，任何要执行的事务都必须包括gas单位预算。解释器跟踪执行过程中剩余的gas单元，如果剩余数量为零，则停止执行并出现错误。 我们考虑了基于寄存器和基于堆栈的字节码解释器，发现具有类型化局部变量的堆栈机器非常适合于Move的资源语义。在局部变量、堆栈和调用者/被调用者之间来回移动值的低级机制紧密地反映了移动程序的高级意图。没有局部变量的堆栈机器将更加冗长，而寄存器机器将使跨过程边界移动资源变得更加复杂。 指令。Move支持六大类字节码指令: 诸如CopyLoc/MoveLoc之类的操作用于将数据从本地变量复制/移动到堆栈，StoreLoc用于将数据从堆栈移动到本地变量 对类型化堆栈值的操作，如将常量推入堆栈，以及对堆栈操作数的算术/逻辑操作。 模块内置程序，例如创建/销毁模块声明类型的Pack和Unpack，MoveToSender /MoveFrom用于在帐户下发布/取消发布模块的类型，而BorrowField用于获取对模块类型之一的字段的引用 与引用相关的指令，如读取引用的ReadRef、写入引用的WriteRef、销毁引用的ReleaseRef和将可变引用转换为不可变引用的FreezeRef。 控制流操作，如条件分支和从过程中调用/返回。 特定区块链的内置操作，如获取事务脚本的发送方地址和创建新帐户。 附录A给出了完整的Move字节码指令列表。Move还提供了诸如sha3之类的密码原语，但是这些原语是作为标准库中的模块实现的，而不是作为字节码指令实现的。在这些标准库模块中，过程被声明为native的，处理过程由Move VM提供。只有VM可以定义新的navite过程，这意味着这些密码原语可以作为普通的字节码指令实现。但是，navite过程非常方便，因为VM可以依赖现有的机制来调用过程，而不是为每个密码原语重新实现调用约定。 字节码验证器 字节码验证器的目标是为提交给发布的任何模块和提交给执行的任何事务脚本静态地强制执行安全属性。如果不通过字节码验证器，就不能发布或执行任何Move程序。 字节码验证器强制执行任何格式良好的Move程序都必须具备的一般安全特性。我们的目标是在未来的工作中为特定于程序的属性开发一个单独的离线验证器(见第7节)。 Move模块或事务脚本的二进制格式编码实体表的集合，如常量、类型签名、结构定义和过程定义。验证人进行的检查分为三类: 结构检查，确保字节码表是格式良好的。这些检查会发现错误，如非法表索引、重复的表项和非法类型签名(如对引用的引用)。 过程体的语义检查。这些检查检测错误，如不正确的过程参数、空引用和复制资源。 将结构类型和过程签名的使用与它们的声明模块相链接。这些检查检测错误，例如非法调用内部过程和使用与其声明不匹配的过程标识符。 在本节的其余部分中，我们将描述语义验证和链接的各个阶段。 控制流图构造 。 验证者通过将指令序列分解为一组基本块(注意，这些基本块与区块链中的事务“块”无关)来构造一个控制流图。每个基本块包含一个连续的指令序列;所有指令集都被划分到块中。这种分解保证了分支只以某些开始的基本块为目标。分解还试图确保生成的块是最大的。然而，字节码验证器的可靠性并不依赖于最大性。 堆栈平衡检查 。 堆栈平衡检查确保被调用方不能访问属于调用方的堆栈位置。基本块的执行发生在局部数组的上下文的变量和堆栈中。该过程的参数是局部变量数组的前缀。跨过程调用传递参数和返回值是通过堆栈完成的。当一个过程开始执行时，它的参数已经加载到它的参数中。假设当一个过程开始执行时，堆栈高度为n，有效的字节码必须满足一个不变条件，即当执行到一个基本块的末尾时，栈高为n。验证者通过单独分析每个基本块并计算每个指令对栈高的影响来确保这一点。它检查高度不低于n，并且在基本块出口为n。唯一的例外是一个以返回指令结尾的块，其中高度必须是n+m(其中m是过程返回的值的数量)。 类型检查 。 验证器的第二阶段检查每条指令和过程(包括构建过程和用户定义过程)是否使用适当类型的参数调用。指令的操作数是位于局部变量或堆栈上的值。过程的局部变量类型已经在字节码中提供。然而，堆栈值的类型是推断出来的。每个基本块分别执行此推理和每个操作的类型检查。由于每个基本块开始时的堆栈高度为n，并且在执行该块时不会低于n，所以我们只需要为从n开始的堆栈后缀建模，以检查块指令的类型。我们使用类型堆栈对这个后缀进行建模，当处理基本块中的指令序列时，类型将被推入和弹出。类型堆栈和静态已知的局部变量类型足以对每个字节码指令进行类型检查。 类别检查 。 验证者在类型检查阶段通过以下附加检查强制执行资源安全: 资源不可复制:CopyLoc不用于resourse类型的本地变量，并且ReadRef不用于类型为resource值引用的堆栈值。 资源不能被销毁:PopUnrestricted不用于resourse类型的堆栈位置，StoreLoc不用于已经拥有资源的本地变量，WriteRef不用于对resource类型值的引用。 资源必须被使用: 当一个过程返回时，没有局部变量可以保存资源值，并且计算堆栈中被调用方的字段必须只保存过程的返回值。 no-resource结构类型不能具有resource类型字段，因此不能通过(例如)用resource字段复制no-resource结构来破坏这些检查。 资源不能被因错误而中断的程序执行所破坏。正如我们在第4.2节中所解释的，事务脚本的部分执行所产生的任何状态更改都不会提交给全局状态。这意味着在运行时失败时位于堆栈或局部变量中的资源将(有效地)返回到事务开始执行之前的位置。 原则上，可以通过不终止的程序执行使资源不可访问。然而，第5.1节中描述的气体计量方案确保了Move程序的执行总是终止。用完gas的执行会因错误而停止，这不会导致资源的丢失(如上所述)。 引用检查 。 使用静态和动态分析相结合的方法检查引用的安全性。静态分析以类似于Rust类型系统的方式使用borrow检查，但是在字节码级别而不是源代码级别执行。这些参考检查确保了两个强属性: 所有引用都指向已分配的存储(即，没有空引用) 所有引用都具有安全的读和写访问权限。引用要么是共享的(没有写访问和自由读访问)，要么是独占的(只有有限的读和写访问) 为了确保这些属性对通过BorrowGlobal创建的全局存储中的引用有效，字节码解释器执行轻量级动态引用计数。解释器跟踪每个已发布资源的未完成引用的数量。如果在对全局资源的引用仍然存在时借用或移动了该资源，则使用此信息停止，并出现错误。 与全局状态连接 在字节码验证过程中，验证器假设当前代码单元使用的外部结构类型和过程ID存在并被真实地表示。链接步骤检查这种假设通过阅读的结构和过程声明全局状态Σ和确保声明匹配使用。具体地说，链接器检查全局状态中的下列声明是否匹配它们在当前代码单元中的用法: 结构声明(名称和类型): 过程签名(名称、可见性、形式参数类型和返回类型)。 Move虚拟机 ：把所有的东西都放一起 Move虚拟机的作用是执行一个区块𝐵从全球的交易状态Σ并产生一个事务影响𝐸代表修改全局状态。影响𝐸可以应用于Σ生成状态Σ′作为区块𝐵的执行的结果。将效果与实际状态更新分离，允许VM在执行失败的情况下实现事务语义。 直观地说，事务效果表示对帐户子集的全局状态的更新。事务效果具有与全局状态相同的结构:它是一个从帐户地址到帐户的部分映射，其中包含Move模块和资源值的规范化序列化表示。规范化序列化实现了从Move模块或资源到字节数组的与语言无关的1-1 function。 为了从状态Σ𝑖−1执行区块𝐵, VM从B中获取一个事务𝑇𝑖 。执行它并产生产生影响𝐸𝑖。,然后应用𝐸𝑖到Σ𝑖−1上去生产状态Σ𝑖，用作区块中生产一个交易的初始状态。整个块的effect有序组合构成了区块的effects。 每个事务都根据工作流进行处理，工作流包括验证事务中的字节码和检查事务发送方的签名等步骤。 现在，块中的事务由VM按顺序执行，但是Move语言被设计为支持并行执行。原则上,执行一个事务可以产生一系列的读取以及一组写𝐸影响。块中的每个事务都可以推测地并行执行，只有当其读/写集与块中的另一个事务冲突时才可以重新执行。检查冲突非常简单，因为Move的树内存模型允许我们使用全局内存单元的访问路径惟一地标识它。如果虚拟机性能成为Libra区块链的瓶颈，我们将在未来探索投机性的执行方案。 move下一步做什么到目前为止，我们已经设计并实现了Move的以下组件: 一个适合区块链执行的编程模型。 一种适合这种可编程模型的字节码语言 用于实现具有强大数据抽象和访问控制的库的模块系统 由序列化器/反序列化器、字节码验证器和字节码解释器组成的虚拟机。 尽管取得了这些进展，但前面还有很长的路要走。最后，我们讨论了一些近期的下一步举措和长期的Move计划。 实现核心libra区块链功能: 我们将使用Move来实现Libra区块链的核心功能:账户、libra coin、libra储备管理、验证器节点的添加和删除、收取和分配交易费用、冷钱包等。这项工作已在进行中 新的语言特性: 我们将向Move语言添加参数多态性(泛型)、集合和事件。参数多态性不会破坏Move现有的安全性和可验证性保证。 此外，我们将开发一个可信的机制，用于版本控制和更新Move模块、事务脚本和发布资源。 提高开发人员的体验： Move IR 是被来开发用作 Move字节码校验器和虚拟机的测试工具。要运行这些组件，IR编译器必须故意生成坏的字节码，这些坏的字节码将被(例如)字节码验证器拒绝。这意味着尽管IR适用于原型化移动程序，但它并不特别友好。为了使Move对第三方开发更具吸引力，我们将改进IR并致力于开发符合人体工程学的Move源语言。 形式化描述与验证方法: 我们将创建一个逻辑规范语言和自动化的形式化验证工具，该工具利用了Move的验证友好设计(参见3.4节)。验证工具链将检查特定于程序的功能正确性属性，这些属性超出了Move字节码验证器执行的安全保证(第5.2节)。我们最初的重点是指定和验证实现Libra区块链核心功能的模块 我们的长期目标是促进一种正确性文化，在这种文化中，用户将通过模块的正式规范来了解其功能。理想情况下，没有一个Move程序员愿意与模块交互，除非它有一个全面的正式规范，并且经过验证符合该规范。然而，实现这一目标将面临若干技术和社会挑战。验证工具应该是精确和直观的。规范必须是模块化和可重用的，但是可读性足够强，可以作为模块行为的有用文档。 支持第三方移动模块： 我们将开发一条第三方模块发布的路径。为Libra用户和第三方开发人员创造良好的体验是一个重大的挑战。首先，向一般应用程序敞开大门一定不能影响系统对核心支付场景和相关金融应用程序的可用性。其次，我们希望避免欺诈、投机和漏洞百出的软件带来的声誉风险。在鼓励高质量软件的同时建立一个开放的系统是一个难题。为高可信模块创建一个市场，并为验证移动代码提供有效的工具等步骤将会有所帮助。 附录A Move 语言参考 []]></content>
      <categories>
        <category>libra</category>
        <category>move语言</category>
      </categories>
      <tags>
        <tag>libra</tag>
        <tag>move语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pbft共识算法问题答案]]></title>
    <url>%2F2019%2F07%2F10%2Fconsensus-pbft-QA%2F</url>
    <content type="text"><![CDATA[本文主要是针对上一篇提出的进行一个详细的解答 pfbt共识为什么至少需要3f+ 1个节点？最坏的情况，系统拜占庭节点为f个，由于消息到达顺序的问题，有可能f个有问题的节点先比f个正常的节点先返回消息，此时又要保证正确的消息比有问题的消息多，所以至少3f+ 1个节点 N - f- f > f => N > 3fpbft共识 parpare和commit 阶段为什么收到需要2f+ 1个相同的回复（包括自己的），f + 1个不行吗？某副本收到了f+ 1相同的消息反馈,如果这个f+ 1个反馈中包含faulty 节点，此时消息是不能作数的，因为faulty可能会发送错误消息给不同的节点，所以需要必须要2f+1个相同的反馈确认才能保证f+1个non-faulty节点正常，这时候即便f个faulty节点给不同人发不同消息也没关系，f+1个non-faulty节点已经形成了统一战线，他们在人数上已经多于那些墙头草了，可以达成一致了。 pbft 共识 客户端为什么需要f + 1个节点的相同回复，f个不行吗？假设只需要从f个不同的节点那里拿到相同的reply，但我们不得不考虑一种情况，即这f个相同的reply全是来自f个faulty节点【系统中至多有f个faulty节点】。如果真是这样的话，很有可能客户端就得到错误的结果。因此为了进一步增强reply的可信度，我们需要来自不同节点的总计(f+1)个相同reply。多出的那一个可以作为对比！ pbft共识 为什么需要三阶段？去除掉commit阶段可以吗？假设我们去掉commit，所有节点收到2f+1(包括自己)的prepare之后就执行操作，会发生什么？ 其实如果顺利的话，即使有f个作恶节点，依然有f+1个正常节点所有节点都会收到正确的结果，最后所有的节点都能顺利的达成一致的结论。这样看来似乎我们完全不需要commit吗？ 但是如果主节点崩溃发生换主，其中只有一个或几个（不是大多数）已经收到了足够的prepare，其他节点因为网络原因没有收到本应该收到的足够多的prepare（异步网络环境没有任何通信保证，只有最终一定会收到的保证），那么那个执行了操作的节点就悲剧了，这个时候新主发起新一轮共识，sequence跟已经执行的操作一致，那个节点到底执行好还是不执行同样sequence的操作？ 那么commit是怎么做到的呢？假设节点收到足够多的prepare进入commit阶段，这个时候发生了一样的换主情形，由于节点还没执行，继续按照新一轮的流程走即可，这个时候sequence不变，但是view改变。 如果已经收到了足够的commit，并且已经执行了操作呢？仿佛陷入了prepare一样的地步…但是实际上因为要产生commit消息，说明2f+1个节点已经prepare了，换主的时候主会去搜集要重放的pre-prepare（2f+1个节点的，必然存在一个诚实节点并且有对应的pre-prepare）,因此会把同样的digest对应的消息view改为自己重发一次，并且注意到commit只需要跟当前的view相同就可以接受，那么实际上commit是对view不敏感的。 简而言之，prepare锁定同一个view下的sequence，commit锁定sequence。 在一个节点数为N的节点中，诚实节点的数量是多少个？(non-faulty)=(2/3)*N+1 CAP定理在pbft中是如何取舍的？PBFT算法将一致性（C）摆在首位，对可用性（A）作了妥协。一旦faulty节点的数量超过f，该系统就不能继续执行客户端的请求【系统会卡住，不能做写操作】。此外，分区容忍是必须要保证的。 设置waterline的目的是什么？假设主节点是坏的，它在给请求编号时故意选择了一个很大的编号，以至于超出了序号的范围，所以我们需要设置一个低水位（low water mark）h和高水位（high water mark）H，让主节点分配的编号在h和H之间，不能肆意分配 PAREPARE 和commit阶段为什么需要保存消息在本地或者内存？PRE-PREPARE为什么不需要？保存消息的主要目的是为了方便viewChange的时候能够恢复消息，重新在新的view上达成共识。PRE-PREPARE阶段各节点还没有发送消息给对方，所以不需要保存。 pbft通信时间复杂度是多少？如何计算的？因为需要三阶段共识，每个阶段各个节点之间都需要通信，所以通信量还是很大的。 假设系统中存在2个拜占庭节点，此时应该最少需要7个节点，下图展示了7个节点通信的过程 请求消息总量为： 1 + 3f + 3f(3f-f) + (3f-f+1)(3f+1) + 3f-1 在上述例子中我们可以进行一个简单计算 12345request messages: 1pre-prepare messages: 3f = 6prepare messages: 3f(3f-f) = 24commit messages: (3f-f+1)(3f+1)= 35reply messages: 3f-1 = 5 可以看出当有7各节点时，pbft需要的消息通信总量竟然达到了71次，这还是只有一次请求的情况下，如果副本更多，消息将会变得更多。 如果在commit阶段view change，会导致达成不了共识吗？会导致之前的view下的请求编号丢失吗？如果commit阶段viewchange，会保留之前commit阶段的请求，不会达成不了共识，也不会丢失请求编号 prepare阶段和commit阶段用来确保那些已经达到commit状态的请求即使在发生viewchange后在新的view里依然保持原有的序列不变，比如一开始在view 0中，共有req 0， req 1， req2三个请求依次进入了commit阶段，假设没有坏节点，那么这四个replicas即将要依次执行者三条请求并返回给Client。但这时主节点问题导致view change的发生，view 0 变成 view 1，在新的view里，原本的req 0， req1， req2三条请求的序列被保留，作数。那些处于pre-prepare和prepare阶段的请求在view change发生后，在新的view里都将被遗弃，不作数。 简单来说就是 如果每个节点都进入了commit阶段（这里要强调的是每个节点都进入这个commit阶段才算是整体进入了commit阶段），这时即使view change，也会保留之前的view里进入commit阶段的请求信息，view change会继续之前的commit阶段请求，不会再重新进入pre-prepare和prepare阶段。]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>pbft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pbft共识算法]]></title>
    <url>%2F2019%2F07%2F09%2Fconsensus-pbft%2F</url>
    <content type="text"><![CDATA[PBFT 是 parctical Byzantine Fault Tolerance（实用拜占庭容错算法）的缩写，它是由BFT算法演化出来的， 所有的BFT算法都为了解决一个问题，那就是在一个不可信的网络里，各个节点如何达成共识。这类问题被称为拜占庭将军问题。什么是拜占庭将军问题呢？拜占庭位于如今的土耳其的伊斯坦布尔，是古代东罗马帝国的首都。拜占庭罗马帝国国土辽阔，为了达到防御目的，每块封地都驻扎一支由将军统领的军队，每个军队都分隔很远，将军与将军之间只能靠信差传递消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定影响将军们达成一致共识。在已知有将军是叛徒的情况下，其余忠诚的将军如何达成一致协议的问题，这就是拜占庭将军问题。 比特币和以太坊代表的POS，EOS代表的DPOS，这些都是公链的算法，适用于众多节点的情况，通过牺牲CAP理论里面的 一致性来达到可用性。PBFT 本身算法的复杂度为O（n^2）他牺牲了可用性来达到一致性，适用于联盟链节点少的情况。 下面图片展示了主流的共识算法 实用拜占庭容错系统（PBFT）降低了拜占庭协议的运行复杂度，从指数级别降低到多项式级别（Polynomial），使拜占庭协议在分布式系统中应用成为可能。 ​ PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，通常假设故障节点数为f个，整个服务节点数为|R|=3f+1个，这里m是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。 PBFT要求共同维护一个状态，所有节点采取的行动一致。为此，需要运行三类基本协议，包括一致性协议、检查点（checkPoint）协议和视图更换(viewChange)协议。我们主要关注支持系统日常运行的一致性协议。一致性协议至少包含若干个阶段：请求（request）、序号分配（pre-prepare）和响应（reply）。根据协议设计的不同，可能包含相互交互（prepare），序号确认（commit）等阶段。 上图显示了一个简化的PBFT的协议通信模式，其中C 为客户端， N0 ~N3 为共识节点。 其中N0 为主节点，N3 为故障节点。整个协议基本过程如下 (一)、客户端发出请求，激活主节点的服务操作。 (二)、主节点接收到请求，采用三阶段协议以向从节点广播请求。 序号分配阶段，主节点给每个请求分配一个序号N，广播序号分配消息和客户端的请求消息m,并将构造PRE-PREPARE 消息给各个从节点。 交互阶段 从节点收到PRE-PREPARE消息，向其他节点广播PARPARE消息。 序号确认阶段，各节点对当前视图（view）的请求和次序验证后，广播Commit消息，执行收到的客户端的请求，然后将结果响应给客户端。 (三) 、客户端等到f+1的相同的响应结果，则认为此次请求成功完成。 在这个机制下有一个视图（view）的概念，类似raft的term的概念。在当期view里面，有一个主节点，其他都是备份节点。主节点将客户端的请求编号并排序，然后发送给副本节点。但是此时主节点有可能是拜占庭的，它有可能给消息编上相同的序号，或者不去给消息分配序号，或者让分配的序号不连续。备份节点有职责去检查这次序号，并根据timeout机制判断主节点是否存活。当出现这些异常情况的时候，副本节点会触发viewChange协议来更换主节点，关于viewChange协议我们后面会讲到，接下来我们详细的分析各个阶段。 视图是连续的整数编号。主节点由公式得出 \mathrm{p}=\mathrm{v} \bmod |\mathrm{N}|这里v 是视图编号，p是副本编号， |N| 是副本集合的个数，当主节点失效就会触发viewChange过程。 请求阶段（REQUEST）客户端向主节点发送 请求, o为请求的具体的操作，t 为请求时客户端追加的时间戳，c为客户端标识。 预准备阶段（PRE-PREPARE）主节点接收到客户端的请求后需要进行以下校验 客户端请求消息签名是否合法，如果合法，则分配一个序号n给该请求，然后向所有的副本节点发送预准备消息，预准备消息的格式为&lt;, m&gt;，这里v是当前视图编号，n为消息序号，这个消息序号必须在[h, H] 之间，具体原因后面分析， d为请求消息的摘要。m是具体的消息。 请求本身是不包含在预准备消息体里面的，这样就可以使预准备消息足够小，因为预准备消息就是为了作为一个证明，证明在这个view里面 请求的的序号被赋值为n，从而可以在viewChange过程中可以进行追索另外一个层面，将“请求排序协议”和“请求传输协议”进行解耦，有利于对消息传输的效率进行深度优化。 准备阶段（PREPARE）副本节点i收到主节点的&lt;，m&gt;消息，需要进行以下校验： a. 主节点PRE-PREPARE消息签名是否正确。 b. 当前副本节点是否已经收到了一条在同一v下并且编号也是n，但是签名不同的PRE-PREPARE信息。 c. d与m的摘要是否一致。 d. n是否在区间[h, H]内。 如果检验通过, 在准备阶段的同时，该节点向所有副本节点发送准备消息,并且将预准备消息和准备消息写入本地log.用于viewChang恢复未完成的请求。 Commit阶段主节点和副本节点收到PREPARE消息，需要进行以下校验： a. 副本节点PARPARE消息签名是否正确。 b. 当前副本节点是否已经收到同一view下的n c. n是否在区间[h,H]里面 d.d是否和当前已收到PRE-PPREPARE中的d相同 非法请求丢弃,如果副本节点i收到了2f+1个验证通过的PREPARE消息，则向其他节点包括主节点发送一条消息，v, n, d, i与上述PREPARE消息内容相同。进行副本节点i的签名。记录COMMIT消息到日志中，用于View Change过程中恢复未完成的请求操作。记录其他副本节点发送的PREPARE消息到log中。 REPLY 阶段主节点和副本节点收到消息，需要进行以下校验： a. 副本节点COMMIT消息签名是否正确。 b. 当前副本节点是否已经收到了同一视图v下的n。 c. d与m的摘要是否一致。 d. n是否在区间[h, H]内。 非法请求丢弃。如果副本节点i收到了2f+1个验证通过的COMMIT消息，说明当前网络中的大部分节点已经达成共识，运行客户端的请求操作o，并返回给客户端，r：是请求操作结果，客户端如果收到f+1个相同的REPLY消息，说明客户端发起的请求已经达成全网共识，否则客户端需要判断是否重新发送请求给主节点。记录其他副本节点发送的COMMIT消息到log中。（补充：需要将针对某个请求的所有接受的消息写入日志，这个日志可以是在内存中的）。 上面介绍PBFT的一致性协议的各个过程，还有两个主要的过程接下来分别介绍 垃圾回收在上述算法流程中，为了确保在每次viewChange中能够恢复之前的请求，每个副本节点会记录一些log到本地，当执行请求后，副本节点需要将请求从本地删除。最简单的做法是当一个节点执行完某条请求并Reply后，，可以广播一条消息，当全网有2f+1个节点都执行完这条请求后就可以删除它的日志了，这样的做法成本比较高，所以可以在多条请求K后（例如100条）执行一次状态同步。这个状态同步消息就是checkPoint消息 副本节点i 发送&lt;给其他节点，n是当前节点保留的最后一个视图的请求编号。该checkPoint消息记录到log中。如果副本节点收到了2f+1个验证过的checkPoint消息，就可以证明该检查点是正确的。具有这个stable checkpoint的节点就可以将所有序号小于等于n的pre-prepare,prepare,commit消息，以及之前的检查点和检查点消息删除。 这是一个理想的情况，实际上当副本i向其他节点发出checkPoint消息后，其他节点还没完成K条请求，所以不会立即对i进行响应，他还是会按照自己的节奏，向前前进,但是此时的checkPoint还未形成stable,为了防止i的请求处理过快，设置一个上文提到的高低水位线[h,H]来解决这个问题。低水位h等于上一个stable checkPoint的值，高水位H = h + L, L为我们设定的值，等于checkPoint周期处理请求数的整数倍，可以设置为L = 2K。当副本节点i处理请求超过高水位线H的时候，此时就需要停一下脚本，等待stable checkPoint 发生变化，再继续前行。 viewChange如果主节点作恶，它可能会给不同的请求编上相同的序号，或者不去分配序号，或者让相邻的序号不连续。备份节点应当有职责来主动检查这些序号的合法性。如果主节点掉线或者作恶不广播客户端的请求，客户端设置超时机制，超时的话，向所有副本节点广播请求消息。副本节点检测出主节点作恶或者下线，发起View Change协议。 副本节点向其他节点广播消息。n是最新的stable checkpoint的编号，C是2f+1验证过的CheckPoint消息集合，P是当前副本节点未完成的请求的PRE-PREPARE和PREPARE消息集合。 当主节点p = v + 1 mod |R|收到2f个有效的VIEW-CHANGE消息后，向其他节点广播消息。V是有效的VIEW-CHANGE消息集合。O是主节点重新发起的未经完成的PRE-PREPARE消息集合。PRE-PREPARE消息集合的选取规则： 选取V中最小的stable checkpoint编号min-s，选取V中prepare消息的最大编号max-s。 在min-s和max-s之间，如果存在P消息集合，则创建&lt;, m&gt;消息。否则创建一个空的PRE-PREPARE消息，即：&lt;, m(null)&gt;, m(null)空消息，d(null)空消息摘要。 副本节点收到主节点的NEW-VIEW消息，验证有效性，有效的话，进入v+1状态，并且开始O中的PRE-PREPARE消息处理流程。如果一条请求在上一个view中到达了committed状态，主节点就选取这个请求开始在新的view中进行第三阶段。但是如果选取的请求在上一view中并没有被prepare，那它的编号n有可能是不被同意的，我们选择在新的view中作废这样的请求。 具体的viewChange过程如下 视图变更可以由超时触发，以防止备份节点无期限地等待请求的执行。备份节点在接收到一个有效请求，但是还没有执行它时，会查看计时器是否在运行，如果没有，那么它将启动计时器；当请求被执行时就把计时器停止。如果计时器超时，则view + 1,并将会把视图变更的消息向全网广播。 Q&amp;A pfbt共识为什么需要3f+ 1个节点？ pbft共识 parpare和commit 阶段为什么收到需要2f+ 1个节点回复（包括自己的），f + 1个不行吗？ pbft 共识 客户端为什么需要f + 1个节点的相同回复，f个不行吗？ pbft共识 为什么需要三阶段？去除掉commit阶段可以吗？ 在一个节点数为N的节点中，诚实节点的数量是多少个？ CAP定理在pbft中是如何取舍的？ 设置waterline的目的是什么？ PAREPARE 和commit阶段为什么需要保存消息在本地或者内存？PRE-PREPARE为什么不需要？ pbft通信时间复杂度是多少？如何计算的？ 如果在commit阶段view change，会导致达成不了共识吗？会导致之前的view下的请求编号丢失吗？ 下面篇文章我会给出这些问题的答案]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>pbft</tag>
      </tags>
  </entry>
</search>
