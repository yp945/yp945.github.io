---
title: Move:一种可编程资源语言
date: 2019-07-10 16:07:23
categories: 
    - libra 
    - move语言
tags:
    - libra
    - move语言
author: ClimbYang
---

## Move:一种可编程资源语言

**Abstract**. 我们为Libra区块链提供了一种安全灵活的编程语言Move， Move是一种可执行的字节码语言，用于实现自定义事务和智能合约。Move的关键特性是能够使用受linear启发的语义定义自定义资源类型。资源永远不能被复制或者被隐式丢弃，只能在程序的存储位置间移动。这些安全保证由Move的类型系统静态执行，尽管有这些特殊保护，资源仍然是一种普通的程序值，它们可以存储在数据结构中作为参数传递给处理逻辑，等等。资源优先是一种很普遍的观念。程序员不仅可以实现安全的数字资产，还可以编写正确的业务用于包装资产和强制访问控制策略的逻辑。Move的安全性和表达性使我们能够在Move中实现Libra协议的重要部分，包括Libra Coin，事务处理和验证器管理.

<!-- more -->

###  介绍

互联网和移动宽带的出现连接了全球数十亿人，为他们提供了获取知识、免费通信以及一系列更低成本、更便捷的服务。这种互联互通也使更多的人能够进入金融生态系统。然而，尽管取得了这些进展，对那些最需要金融服务的人来说，获得金融服务的机会仍然有限。

Libra的任务是改变这种状况。在本文中，我们提出了一种新的编程语言Move，用于在Libra协议中实现自定义事务逻辑和智能合约。为介绍Move，我们:

1. 描述在区块链上表示数字资产的挑战 (第二节).
2. 解释我们的Move设计如何解决这些挑战 (第三节).
3. 给出一个样例用以概述Move的主要特性和编程模型 (第四节).
4. 深入研究语言和虚拟机设计的技术细节 (第五节, 第六节,和附录A).
5. 最后，总结一下我们在Move方面取得的进展，描述我们的语言发展计划，并概述我们在Libra区块链上支持第三方Move代码的路线图

**观众** 本文针对两种不同的受众群体:

- 不熟悉区块链系统的编程语言研究人员。我们鼓励这些读者从头到尾阅读这篇文章，但是我们警告说，我们有时可能在没有为不熟悉的读者提供足够上下文的情况下引用区块链概念。
- 区块链开发人员可能不熟悉编程语言的研究，但有兴趣学习移动语言。我们鼓励观众从这里开始(第三节)。我们注意，第5、第6部分和附录A中包含一些编程语言术语和形式化，这些术语和形式化可能是不熟悉的。

### 在区块链上管理数字资产

我们将从抽象层次简要解释区块链开始，以帮助读者理解像Move这样的“区块链编程语言”所扮演的角色。本讨论有意省略了区块链系统的许多重要细节，以便集中讨论与语言角度相关的特性。

####  区块链的抽象视图

区块链是一个复制状态机。系统中的复制器称为验证器。系统用户向验证器发送事务。每个验证器都了解如何执行事务，以便将其内部状态机从当前状态转换到新状态.

验证器利用它们对事务执行的共享理解，遵循一致协议来集体定义和维护复制状态。如果

- 验证器从相同的初始状态开始，
- 验证器就下一个事务应该是什么达成一致,
- 验证器会产生确定的状态转换

然后验证器还将对下一个状态达成一致。反复应用此方案允许验证器处理事务，同时继续就当前状态达成一致。

注意，协商一致协议和状态转换组件对彼此的实现细节并不敏感。只要协商一致协议确保事务之间的总顺序和状态转换方案是确定的，组件就可以和谐地交互。

####  在开放系统中编码数字资产

像Move这样的区块链编程语言的作用是决定如何表示转换和状态。为了支持丰富的金融基础设施，Libra的区块链状态必须能够在给定的时间点对数字资产的所有者进行编码。此外，状态转换应该允许资产的转移。

在区块链编程语言的设计中必须考虑另一个因素。与其他公共区块链一样，Libra区块链是一个开放的系统,任何人都可以查看当前的区块链状态或将事务提交给验证器(即，建议状态转换)。传统上，管理数字资产的软件(如银行软件)是在一个封闭的系统中运行的，具有特殊管理控制.所有参与者地位平等。参与者可以提出任何她喜欢的状态转换，但是系统不应该允许所有的状态转换。例如，Alice可以自由地提出一个转移Bob拥有的资产的状态转换。状态转换函数必须能够识别此状态转换无效并拒绝它.

在一个开放的软件系统中，选择转换和状态的表示形式来编码数字资产的所有权是很有挑战性的。特别是，物理资产有两个属性很难在数字资产中编码

- **稀缺性**。应该控制系统中的资产供应。应该禁止复制现有资产，创建新资产应该是一项特权操作。
- **访问控制**.系统的参与者应该能够通过访问策略保护来访问她的资产

为了直观的表示，我们将看到这些问题是如何在表示状态转换的一系列strawman原型中出现的。我们将假设区块链跟踪一个称为StrawCoin的数字资产，区块链状态G结构为映射用户标识的键值存储(用加密公钥表示)到自然数值，自然数值编码每个用户持有的稻草币提案由一个事务脚本组成，该脚本将使用给定的评估规则进行评估，生成一个应用于全局状态的更新。我们将编写**G[𝐾]:=𝑛** 表示存储在密钥𝐾在全球区块链状态的价值为n。

每个提案的目标都是设计一个足够有表现力的系统，使Alice能够发送StrawCoin到Bob，但其限制足以防止任何用户违反**稀缺性**或**访问控制**属性。这些提议并不试图解决诸如重放攻击之类的安全问题，这些问题很重要，但与我们讨论的稀缺性和访问控制无关。

**稀缺性**。 最简单的建议是直接将更新编码到事务脚本中的状态

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g47grkxn9hj20g8034dfw.jpg?ynotemdtimestamp=1562746207621)

这个表示可以编码将StrawCoin从Alice发送到Bob。但它有几个严重的问题。首先，这一提议并没有强化StrawCoin的稀缺性。Alice能给尽可能多的StrawCoin她高兴“凭空”通过发送事务⟨Alice,100⟩。因此，Alice发送给Bob的StrawCoin实际上是没有价值的，因为Bob也可以很容易地为自己创建这些Coin.

稀缺性是有价值实物资产的重要属性。像黄金这样的稀有金属自然是稀缺的，但数字资产并不存在固有的物理稀缺。以字节序列编码的数字资产，如G[Alice]→10，在物理上并不比另一个字节序列(如G[Alice]→100)更难生成或复制。相反，评估规则必须以编程方式实施稀缺性。

让我们考虑第二个考虑到稀缺性的提议:

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g47lezmqx6j20i304v0t2.jpg?ynotemdtimestamp=1562746207621)

在这个方案下,事务脚本指定的公钥𝐾𝑎发件人,Alice,和公钥𝐾𝑏接收者 Bob。评价规则现在检查的数量StrawCoin储存在𝐾𝑎至少𝑛之前执行任何更新。如果检查成功,评价规则减去从StrawCoin 𝑛 储存在发送方的密钥和 𝑛补充到储存在收件人钥匙下的StrawCoin。在此方案下，执行一个有效的事务脚本通过保存系统中的StrawCoin数量来强制执行稀缺性。Alice不能再创造了，他只能从账户中给Bob StrawCoin。

**访问控制。** 尽管第二项提案解决了资源稀缺的问题，但它仍然存在一个问题:Bob可以发送使用属于Alice的稻草币的交易。例如,没有评价规则将阻止Bob发送事务⟨Alice,100,Bob⟩。我们可以通过添加基于数字签名的访问控制机制来解决这个问题:

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g47lmd0zx1j20od04r3z2.jpg?ynotemdtimestamp=1562746207621)

这个方案要求Alice用她的私钥签署事务脚本。我们写𝑆𝐾(𝑚)签署消息𝑚使用私钥与公钥𝐾配对。评价规则使用verify_sig函数对Alice的检查签名公钥𝐾𝑎。如果没有验证签名，则不执行更新。这个新规则通过使用数字签名的不可伪造性来防止Alice从她自己的账户以外的任何账户借记StrawCoin，从而解决了之前提议的问题.

另外，请注意，在第一个strawman原型中实际上不需要评估规则——提议的状态更新直接应用于键值存储。但是，随着我们对这些建议的深入研究，在执行更新的先决条件和更新本身之间出现了明显的分离,评估规则通过评估脚本来决定是否执行更新以及执行什么更新。这种分离是基本的，因为执行访问控制和稀缺性策略不可避免地需要某种形式的评估——用户提出状态更改必须执行计算以确定状态更改是否符合策略。在一个开放的系统中，不能信任参与者执行策略并向状态提交直接更新(如第一个建议中所述)。相反，访问控制策略必须由评估规则在链上强制执行.

####  现有的区块链语言

StrawCoin是一种玩具语言，但它试图捕捉比特币脚本的本质和和Ethereum虚拟机字节码语言(尤其是后者)。虽然这些语言比StrawCoin更复杂，但它们面临许多相同的问题:

1. **资产的间接表示**。资产使用整数编码，但整数值与资产不同。实际上，没有表示的类型或值在 Bitcoin/Ether/ StrawCoin 中， 这使得编写使用资产的程序变得非常困难，并且容易出错。诸如将资产传入/传出过程或将资产存储在数据结构中的模式需要特殊的语言支持。
2. **稀缺性是不可扩展的**。语言只代表一种稀缺资产。此外，稀缺性保护直接硬编码在语言语义中。希望创建自定义资产的程序员必须在没有语言支持的情况下仔细地重新实现稀缺性。
3. **访问控制不灵活**。模型执行的唯一访问控制策略是基于公钥的签名方案。与稀缺性保护一样，访问控制策略也深深地嵌入到语言语义中。如何扩展该语言以允许程序员定义自定义访问控制策略并不明显。

**Bitcoin Script** 。 Bitcoin Script有一个简单而优雅的设计，专注于表示用于消费比特币的自定义访问控制策略。全局状态由一组未使用的事务输出(UTXOs)组成。比特币脚本程序提供的输入(例如数字签名)满足它所使用的旧UTXOs的访问控制策略，并为它创建的新UTXOs指定定制的访问控制策略。由于比特币脚本包含强大的数字签名检查指令(包括多签名支持)，程序员可以编码多种访问控制。

然而比特币脚本的表达能力从根本上是有限的。程序员不能定义自定义数据类型(因此也不能定义自定义资产)或过程，而且语言也不完整。合作各方可以通过复杂的多事务协议或通过“彩色硬币”非正式地定义自定义资产来执行更丰富的计算。然而，这些方案的工作原理是将复杂性推到语言之外，因此不支持真正的可扩展性。

**Ethereum Virtual Machine bytecode** 。 Ethereum是一个开创性的系统，演示了如何使用区块链系统不仅仅用于支付。Ethereum虚拟机(EVM)字节码程序员可以发布与ether之类的资产交互的智能合约，并使用图灵完备语言定义新资产。EVM支持比特币脚本所不能支持的东西，例如用户定义的过程、虚拟调用、循环和数据结构。

然而，EVM的的表现为代价高昂的编程错误打开了大门。就像StrawCoin是一种ether货币，在语言中具有特殊的地位，它的实现方式强调了稀缺性,但是定制资产的实现者(例如，通过ERC20标准)不继承这些保护(如第(2)所述)-他们必须小心不要引入允许复制、重用或丢失资产的bug。这是具有挑战性的，因为结合了间接表示问题中描述,以及EVM的高度动态行为。特别是，将ether转移到智能合约涉及到动态分派，这导致了一类新的bug，称为可重入性漏洞。引人注目的漏洞，如DAO攻击和Parity Wallet攻击，已经允许攻击者窃取价值数百万美元的加密货币。

### Move设计目标

Libra的使命是使一个简单的全球货币和金融基础设施，使数十亿人的受益。Move语言的设计目的是提供一个安全的、可编程的基础，在此基础上可以构建这个愿景。Move必须能够以精确、可理解和可验证的方式表达Libra的货币和治理规则。从长远来看，Move必须能够编码构成金融基础设施的丰富多样的资产和相应的业务逻辑。

为了满足这些需求，我们设计Move时考虑了四个关键目标:头等资产、灵活性、安全性和可验证性

#### 资源是头等公民

区块链系统允许用户编写与数字资产直接交互的程序。正如我们在第2.2节中讨论的，数字资产具有特殊的特性，这些特性将它们与传统编程中使用的值(如布尔值、整数和字符串)区分开来。使用资产进行编程的健壮而优雅的方法需要保持这些特征的表示形式。

Move的关键特性是能够使用线性逻辑激发的语义定义自定义资源类型:资源永远不能复制或隐式丢弃，只能在程序存储位置之间移动。这些安全保证由Move的类型系统静态执行。尽管有这些特殊的保护，资源仍然是普通的程序值——它们可以存储在数据结构中，作为参数传递给过程，等等。资源放在第一位置是一个非常普遍的概念，程序员不仅可以使用它来实现安全的数字资产，还可以用它来编写正确的业务逻辑来包装资产和执行访问控制策略。

Libra coin本身就是一种普通的Move资源，在语言中没有特殊的地位。由于Libra coin代表Libra 储备管理的真实世界资产，因此Move必须允许创建资源(例如，当新的真实世界资产进入Libra储备时)、修改(例如，当数字资产更改所有权时)和销毁(例如，当支持数字资产的物理资产被出售时)。Move程序员可以使用模块保护对这些关键操作的访问。Move模块类似于其他区块链语言中的智能合约。模块声明资源类型和过程，这些类型和过程编码用于创建、销毁和更新其声明的资源的规则。模块可以调用其他模块声明的过程并使用其他模块声明的类型。然而，模块强制执行强数据抽象——类型在其声明模块内部是透明的，而在其外部是不透明的。此外，对资源类型T的关键操作只能在定义T的模块中执行。

#### 灵活性

Move通过事务脚本为Libra增加了灵活性。每个Libra事务都包含一个事务脚本，该脚本实际上是事务的主要过程。事务脚本是一个包含任意移动代码的过程，允许定制事务。一个脚本可以调用发布在区块链中的多个模块的过程，并对结果执行本地计算。这意味着脚本可以执行表达性的一次性行为(例如向一组特定的接收者付费)或可重用行为(通过调用封装可重用逻辑的单个过程)。

通过安全而灵活的代码组合，Move模块提供了一种不同的灵活性。在高层次上，Move中modules/resources/procedures 之间的关系类似于面向对象编程中的类/对象/方法之间的关系。然而，有一些重要的区别——一个Move模块可以声明多个资源类型(或零资源类型)，而Move过程没有self或这个值的概念。Move模块与ml风格的模块的限定版本最为相似。

#### 安全性

Move必须拒绝不满足关键属性(如资源安全性、类型安全性和内存安全性)的程序。我们如何选择一个可执行的表示，以确保每一个在区块链上执行的程序满足这些性质?两种可能的方法是:(a)使用带有检查这些属性的编译器的高级编程语言，或者(b)使用低级非类型化程序集并在运行时执行这些安全检查。Move采取的方法介于这两个极端之间。Move的可执行格式是一种类型字节码，它比assembly级别高，但比source language 级别低。在链上检查资源、类型和内存安全性，然后由字节码解释器直接执行。此选项允许Move提供通常与源语言关联的安全保证，但不需要将源编译器添加到可信计算基础中，也不需要将编译成本添加到事务执行的关键路径中。

#### 可验证性

理想情况下，我们将通过链上字节码分析或运行时检查检查Move程序的每个安全属性。不幸的是，这是不可行的。我们必须仔细权衡安全保证的重要性和通用性，以及使用链上验证来执行安全保证的计算成本和增加的协议复杂性。

我们的方法是尽可能多地执行关键安全特性的轻量级链上验证，但是设计Move语言来支持高级的离线静态验证工具。我们做了几个设计决定，使得Move比大多数通用语言更适合静态验证:

1. **没有动态调用**。可以静态地确定每个调用站点的目标。这使得验证工具可以很容易地精确地推断过程调用的效果，而无需执行复杂的调用图构造分析。
2. **有限的可变性。 **对Move值的每个突变都是通过引用发生的,引用是必须在单个事务脚本的范围内创建和销毁的临时值。Move的字节码验证器使用类似于Rust的“借用检查”方案，以确保在任何时间点最多存在一个对值的可变引用。此外，该语言确保全局存储始终是树而不是任意图。这允许验证工具模块化有关写操作效果的推理。
3. **模块化** 。 Move模块执行数据抽象并本地化资源上的关键操作。模块启用的封装与Move类型系统强制实施的保护相结合，确保为模块类型建立的属性不会被模块外部的代码违反。我们希望通过这种设计，可以在不考虑其客户机的情况下单独查看模块，从而对重要的模块不变量进行详尽的功能验证。

静态验证工具可以利用Move的这些属性来准确有效地检查运行时是否没有出现故障(例如整数溢出)，以及重要的特定于程序的功能正确性属性(例如，锁定在支付通道中的资源最终可以由参与者声明)。我们将在第7节中分享关于功能验证计划的更多细节。

### Move概述

我们将介绍Move的基础知识，方法是遍历简单对等支付中涉及的事务脚本和模块。该模块是实际Libra Coin实现的简化版本。示例事务脚本演示了模块外部恶意或粗心的程序员不能违反模块资源的关键安全不变量。示例模块展示了如何实现一个利用强大的数据抽象来建立和维护这些不变量的资源。

本节中的代码片段是用Move中间代码(IR)编写的。Move IR的级别足够高，可以编写人类可读的代码，但又足够低，可以直接转换来Move字节码。我们提供 Move IR代码，因为基于堆栈的Move字节码更难以读取，而且我们目前正在设计一种Move源代码语言(请参阅第七节）我们注意到，在执行代码之前，Move类型系统提供的所有安全保证都在字节码级别进行检查。

#### 点对点支付交易脚本

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g47r3k6ky8j20pn0343z4.jpg?ynotemdtimestamp=1562746207621)

此脚本接受两个输入:付款接收方的帐户地址和表示要转移到接收方的Coin数量的无符号整数。执行此脚本的效果很简单: amount数量的Coin将从`sender`转移到`payee`。这需要两个步骤。在第一步中，发送方从存储在`0x0.Currency`的模块调用一个名为抽出`withdraw_from_sender`的过程 ,正如我们将在第4.2节中解释的那样,

`0x0`是存储在模块里的帐户地址，`Currency`是模块的名称。这个过程返回的值coin是一个资源值，其类型为`0x0.Currency.Coin` ,在第二步中，发送方通过将coin资源值移动到`0x0.Currency` 的 deposit过程， 将资金转移到`payee`。

这个例子很有趣，因为它非常微妙。Move的类型系统将拒绝相同代码中可能导致不良行为的小变体。特别是，类型系统确保资源永远不会被复制、重用或丢失。例如，类型系统会拒绝以下三个对脚本的更改:

**通过改变 move(coin) to copy(coin)来复制货币**。 注意，示例中变量的每次使用都被包装在`copy()`或`move()`中。

继Rust和c++之后，Move实现了Move语义。每次读取移动变量x时，必须指定使用是将x的值移出该变量(使x不可用)，还是复制该值(使x可继续使用)。无限制的值类似`u64` 和 `address` 既可以被move 也可以被copy。 但是资源值只能被 move，试图copy资源值(例如，在上面的例子中使用copy(coin))将在字节码验证时导致错误。

**通过两次编写move(coin)来重用货币** 添加 `0x0.Currency.deposit(copy(some_other_payee), move(coin))`这一行在以上的例子会让投币人“花”两次Coin，第一次花在收款人身上，第二次花在其他收款人身上。这种不受欢迎的行为对于物理资产是不可能的， 幸运的是，此举将被拒绝。变量coin在第一次移动后不可用，第二次移动将触发一个字节码验证错误。

**忘记move(coin)而丢失货币** 。 Move语言实现了线性的资源，这些资源必须被精确地移动一次。未能move资源(例如，删除上面示例中包含move(coin)的行)将触发字节码验证错误。这可以防止程序员意外地(或有意地)丢失对资源的跟踪。这些担保超出了纸币等实物资产所能提供的范围。

我们使用“资源安全”这个术语来描述移动资源永远不会被复制、重用或丢失的保证。这些保证非常强大，因为Move程序员可以实现同样享受这些保护的自定义资源。正如我们在3.1节中提到的，即使是Libra货币也被实现为自定义资源，在Move语言中没有特殊的地位。

#### Currency模块

在本节中，我们将展示上面示例中使用的Currency模块的实现如何利用资源安全性来实现安全的可替换资产。我们将首先解释一下运行move代码的区块链环境

**入门：** **Move执行模型** 正如我们在第3.2节中解释的，Move有两种不同的程序:事务脚本(如第4.1节中概述的示例)和模块(如货币模块，我们很快就会讲到 类似于示例的事务脚本包含在每个用户提交的事务和模块的调用过程中，以更新全局状态。执行事务脚本是全有或全无的——要么执行成功完成，脚本执行的所有写操作都提交到全局存储，要么执行终止时出现错误(例如，由于断言失败或耗尽gas错误)，什么也不提交。事务脚本是一段一次性使用的代码——在执行之后，其他事务脚本或模块不能再次调用它。

相反，模块是一段以全局状态发布的长生命周期代码。模块名称`0x0.Currency`。上面示例中使用的货币包含发布模块代码的帐户地址`0x0`。全局状态结构为从帐户地址到帐户的映射。

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g47qgxlm00j20qm09hq3x.jpg?ynotemdtimestamp=1562746207621)

每个帐户可以包含0个或多个模块(以矩形表示)和一个或多个资源值(以柱面表示)。 例如，地址`0x0`处的帐户包含一个模块`0x0.Currency`和类型`0x0.Currency.Coin`的资源值。地址`0x1`的账户有两个资源和一个模块;地址为`0x2`的帐户有两个模块和一个资源值。

帐户最多可以包含一个给定类型的资源值，最多可以包含一个具有给定名称的模块。地址0x0处的帐户将不允许包含额外的`0x0. Currency.Coin` 或者其他叫做`Currency`的模块。但是，地址`0x1`的帐户可以添加一个名为Currency的模块。在这种情况下，`0x0`也可以保存`0x1.Currency.Coin`类型的资源。`0x0.currency.coin`和`0 x1.currency.coin`是不同的类型，不能互换使用;声明模块的地址是类型的一部分

注意，在帐户中最多允许给定类型的单一资源并不受限制。此设计为顶级帐户值提供了一个可预测的存储模式。程序员仍然可以通过定义自定义包装器资源(例如，资源**TwoCoins** {c1: 0x0.Currency.Coin, c2: 0x0.currency.Coin})

**声明Coin资源**。在解释了模块如何适合于Move执行模型之后，我们终于准备好查看货币Currency模块内部了

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g47r4cvdomj20n403ngln.jpg?ynotemdtimestamp=1562746207621)

此代码声明一个名为Currency的模块和一个由模块管理的名为Coin的资源类型。Coin是一种Struct类型，其单个字段值类型为u64(64位无符号整数)。Coin的结构在货币模块之外是不透明的。其他模块和事务脚本只能通过模块公开的公共过程编写或引用value字段。同样，只有Currency模块的过程才能创建或销毁类型Coin的值。此方案支持强数据抽象——模块作者可以完全控制其声明资源的访问、创建和销毁。在货币模块公开的API之外，其他模块只能对硬币执行移动操作。资源安全性禁止其他模块复制、销毁或重复移动资源。

**Implementing deposit** 。让我们研究一下前面小节中的事务脚本调用的Currency.deposit过程是如何工作的

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g47rcurm82j20mz05fmyj.jpg?ynotemdtimestamp=1562746207621)

在较高的级别上，此过程以Coin资源作为输入，并将其与存储在收款人帐户中的Coin资源相结合。它通过:

1. 销毁输入硬币并记录其价值
2. 获取对收款人帐户下存储的唯一Coin资源的引用
3. 将收款人的Coin的价值与传递给程序的Coin的价值相加

这个过程的底层机制有一些方面值得解释。绑定到`to_deposit`的Coin资源由存款程序拥有。要调用该过程，调用者需要将绑定到to_deposit的硬币移动到被调用者中(这将防止调用者重用它)

第一行调用的`Unpack`过程是用于操作模块声明的类型的几个模块内置程序之一,`Unpack<T>` 是删除一个资源类型T的唯一方式。它接受类型为T的资源作为输入，销毁它，并返回绑定到资源字段的值。像`Unpack`这样的模块内建只能用于当前模块中声明的资源。在Unpack的情况下，此约束可防止其他代码破坏Coin，从而允许Currency模块设置自定义的销毁Coin资源的前提条件(例如，它只能选择允许销毁零值钱币)

第三行调用的`BorrowGlobal`过程也是一个模块构建，`BorrowGlobal<T>`将一个地址作为输入，并返回对在该地址下发布的T的惟一实例的引用。 这意味着上面代码中的coin_ref类型是`&mut Coin` 对Coin资源的可变引用,这不是Coin-这是一个拥有的Coin资源。下一行将引用值绑定到`coin_ref`，以便获得指向硬币值字段的`coin_value_ref`引用。程序的最后几行读取收款人Coin资源的前一个值，并修改`coin_value_ref`以反映存款金额

我们注意到，Move类型系统不能捕获模块中所有的实现错误。例如，类型系统不会确保所有现存Coin的总价值都通过存款通知来保存, 如果程序员写错了`*move(coin_value_ref) = 1 + move(coin_value) + move(to_deposit_value)`在最后一行，类型系统将毫无疑问地接受代码,这就明确了职责划分:在模块内部为Coin建立合适的安全不变量是程序员的工作，确保模块外部的Coin客户端不能违反这些不变量是类型系统的工作。

**Implementing withdraw_from_sender**。 在上述实现中，通过存款程序存入资金不需要任何授权——任何人都可以调用存款。相反，从帐户中取款必须受到访问控制策略的保护，该策略向货币资源的所有者授予独占特权。让我们看看由对等支付事务脚本调用的抽出`withdraw_from_sender`过程如何实现此授权

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g48j57c6usj20kd06lgn6.jpg?ynotemdtimestamp=1562746207621)

这个过程几乎与存款相反，但也不完全相反。它:

1. 获取对发送方帐户下发布的Coin类型的惟一资源的引用
2. 将referenced Coin 的值减去输入量
3. 创建并返回一个带有value amount的新Coin资源

这个过程执行的访问控制检查有点微妙。deposit过程允许调用者指定传递给`BorrowGlobal`的地址，但是withdraw_from_sender只能传递`GetTxnSenderAddress`返回的地址，此过程是几个内置事务之一，允许Move代码从当前正在执行的事务中读取数据。`Move virtual machine`在执行事务之前对发送方地址进行身份验证。使用借用全局内置函数以这种方式确保交易的发送方只能从自己的Coin资源中提取资金。

与所有内置模块一样，`BorrowGlobal<Coin>`只能在声明的模块中调用Coin。如果`Currency`模块没有公开一个返回`BorrowGlobal`结果的过程，则`Currency`模块之外的代码无法获得对全局存储中发布的Coin资源的引用。

在降低事务发送方的Coin资源的值之前，该过程断言硬币的值大于或等于使用`RejectUnless`指令输入的正式金额。这可以确保发送者不能取比她多的钱。如果该检查失败，当前事务脚本的执行将停止，它执行的任何操作都不会应用到全局状态。

最后，该过程按数量减少发送方硬币的价值，并使用`Pack`(Pack module builtin)创建一个新的Coin资源。`Pack<T>`创建了一个T类型的新资源，就像`Unpack<T>`一样，`Pack<T>`只能在资源T的声明模块中调用。在这里，`Pack`用于创建一个类型为Coin的资源new_coin并将其移动到调用方。调用者现在拥有这个Coin资源，可以将它移动到任何她喜欢的地方。在第4.1节的示例事务脚本中，调用者选择将Coin存入收款人的帐户。

### Move语言

在本节中，我们将介绍Move语言、字节码验证器和虚拟机的半形式化描述。附录A详细地列出了所有这些组件，但没有附带任何文字。我们这里的讨论将使用附录中的摘录，并偶尔引用其中定义的符号。

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g48luo08b5j20kg03bt8v.jpg?ynotemdtimestamp=1562746207621)

Move的目标是使程序员能够定义全局区块链状态，并安全地实现更新全局状态的操作。正如我们在第4.2节中所解释的，全局状态被组织为从地址到帐户的部分映射。帐户同时包含资源数据值和模块代码值。帐户中的不同资源必须具有不同的标识符。帐户中的不同模块必须有不同的名称。

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g48lx35jbqj20kc04xq3e.jpg?ynotemdtimestamp=1562746207621)

模块由名称、结构声明(包括资源，稍后我们将解释)和程序声明。代码可以使用由模块的帐户地址和模块名称组成的唯一标识符引用已发布的模块。模块标识符充当一个命名空间，它限定模块外部代码的结构类型和过程的标识符。Move模块支持强大的数据抽象。模块的过程编码用于创建、编写和销毁模块声明的类型的规则。类型在其声明模块内部是透明的，在外部是不透明的。Move模块还可以通过`MoveToSender`指令强制发布帐户下的资源的先决条件，通过`BorrowGlobal`指令获取对帐户下资源的引用，并通过`MoveFrom`指令从帐户中删除资源。

模块使Move程序员能够灵活地为资源定义丰富的访问控制策略。例如，模块可以定义一个只能在f字段为零时销毁的资源类型，或者一个只能在特定帐户地址下发布的资源。

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g48mjzy1g0j20k904bgly.jpg?ynotemdtimestamp=1562746207621)

Move支持基本类型，包括布尔值、64位无符号整数、256位帐户地址和固定大小的字节数组。struct是由模块声明的用户定义类型。通过用资源类型标记结构类型，可以将其指定为资源。所有其他类型，包括非资源结构类型和基本类型，都称为无限制类型。

资源类型的变量是资源变量;无约束类型的变量是无约束变量。字节码验证器对资源类型的资源变量和结构字段施加限制，资源变量不能复制，必须始终移动。资源变量和资源类型的struct字段都不能重新分配——这样做会破坏先前保存在存储位置中的资源值。此外，对资源类型的引用不能取消引用，因为这将生成基础资源的副本。相反，不受限制的类型可以复制、重新分配和取消引用。

最后，不受限制的结构类型可能不包含具有资源类型的字段。此限制确保(a)复制无限制结构不会导致复制嵌套资源，(b)重新分配无限制结构不会导致销毁嵌套资源。

引用类型可以是可变的，也可以是不可变的;不允许通过不可变引用进行写操作。字节码验证器执行引用安全检查，执行这些规则以及对资源类型的限制(参见5.2节)。

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g48qf8q2fgj20jo07q0tg.jpg?ynotemdtimestamp=1562746207621)

除了结构和基本值之外，Move还支持引用值。引用与其他移动值不同，因为它们是瞬态的。字节码验证器不允许引用类型的字段。这意味着必须在事务脚本执行期间创建引用，并在事务脚本结束之前释放引用。

对struct值形状的限制确保全局状态始终是树而不是任意图，状态树中的每个存储位置可以使用其正规的代表访问路径——一个存储树中的路径从一个根(一个局部变量𝑥或全球资源关键𝑔)到后代节点被字段标识符𝑓序列标记。

该语言允许对原始值和结构的引用，但不允许对其他引用的引用。Move程序员可以使用`BorrowLoc`指令获取对本地变量的引用，使用`BorrowField`指令获取对结构的字段的引用，以及使用`BorrowGlobal`指令。后两种构造只能用于当前模块中声明的结构类型。

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g48qtgt374j20k305v3z9.jpg?ynotemdtimestamp=1562746207621)

过程签名由可见性、类型化形式参数和返回类型组成。过程声明包含签名、类型化局部变量和字节码指令数组。过程可见性可以是公开的，也可以是内部的。内部过程只能由同一模块中的其他过程调用。任何模块或事务脚本都可以调用公共过程。

区块链状态由一个事务脚本更新，该脚本可以调用当前发布在帐户下的任何模块的公共过程。事务脚本只是一个没有关联模块的过程声明。

一个过程可以由它的模块标识符和它的签名唯一地标识。调用字节码指令需要一个惟一的过程ID作为输入。这确保了Move中的所有过程调用都是静态确定的——没有函数指针或虚拟调用。此外，模块之间的依赖关系通过构造是非循环的。模块只能依赖于线性事务历史中较早发布的模块。无循环模块依赖关系图和缺乏动态分派的组合强制执行一个强执行不变量:属于模块中的过程的所有堆栈帧必须是连续的。因此，在Move模块中没有与Ethereum智能合约的可重入性问题等价的问题。

在本节的其余部分中，我们将介绍字节码操作及其语义(第5.1节)，并描述字节码验证器在允许执行或存储模块代码之前执行的静态分析(第5.2节)。

#### 字节码解释器

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g48r48oebsj20ie04l3yz.jpg?ynotemdtimestamp=1562746207621)

Move字节码指令由基于堆栈的解释器执行，类似于公共语言运行时和Java虚拟机。一条指令从堆栈中使用操作数并将结果推入堆栈。指令也可以从当前过程的局部变量(包括形式参数)中移动和复制值。

字节码解释器支持过程调用。传递给被调用方的输入值和返回给调用方的输出值也通过堆栈进行通信。首先，调用者将参数推送到堆栈上的过程。接下来，调用者调用`Call`指令，该指令为被调用者创建一个新的调用堆栈帧，并将推入的值加载到被调用者的本地变量中。最后，字节码解释器开始执行被调用过程的字节码指令。

字节码的执行通过按顺序执行操作来进行，除非有分支操作导致跳转到当前过程中静态确定的偏移量。当被调用方希望返回时，它将返回值推入堆栈并调用`Return`指令。控制返回给调用者，调用者将查找堆栈上的输出值。

Move程序的执行以类似EVM的方式进行计量。每个字节码指令都有一个相关的gas单位成本，任何要执行的事务都必须包括gas单位预算。解释器跟踪执行过程中剩余的gas单元，如果剩余数量为零，则停止执行并出现错误。

我们考虑了基于寄存器和基于堆栈的字节码解释器，发现具有类型化局部变量的堆栈机器非常适合于Move的资源语义。在局部变量、堆栈和调用者/被调用者之间来回移动值的低级机制紧密地反映了移动程序的高级意图。没有局部变量的堆栈机器将更加冗长，而寄存器机器将使跨过程边界移动资源变得更加复杂。

指令。Move支持六大类字节码指令:

- 诸如`CopyLoc/MoveLoc`之类的操作用于将数据从本地变量复制/移动到堆栈，`StoreLoc`用于将数据从堆栈移动到本地变量
- 对类型化堆栈值的操作，如将常量推入堆栈，以及对堆栈操作数的算术/逻辑操作。
- 模块内置程序，例如创建/销毁模块声明类型的`Pack`和`Unpack`，`MoveToSender` /`MoveFrom`用于在帐户下发布/取消发布模块的类型，而`BorrowField`用于获取对模块类型之一的字段的引用
- 与引用相关的指令，如读取引用的`ReadRef`、写入引用的`WriteRef`、销毁引用的`ReleaseRef`和将可变引用转换为不可变引用的`FreezeRef`。
- 控制流操作，如条件分支和从过程中调用/返回。
- 特定区块链的内置操作，如获取事务脚本的发送方地址和创建新帐户。

附录A给出了完整的Move字节码指令列表。Move还提供了诸如sha3之类的密码原语，但是这些原语是作为标准库中的模块实现的，而不是作为字节码指令实现的。在这些标准库模块中，过程被声明为`native`的，处理过程由Move VM提供。只有VM可以定义新的navite过程，这意味着这些密码原语可以作为普通的字节码指令实现。但是，navite过程非常方便，因为VM可以依赖现有的机制来调用过程，而不是为每个密码原语重新实现调用约定。

#### 字节码验证器

![img](http://ww1.sinaimg.cn/large/c26c1fe3gy1g48s6e9msgj20hr03imxd.jpg?ynotemdtimestamp=1562746207621)

字节码验证器的目标是为提交给发布的任何模块和提交给执行的任何事务脚本静态地强制执行安全属性。如果不通过字节码验证器，就不能发布或执行任何Move程序。

字节码验证器强制执行任何格式良好的Move程序都必须具备的一般安全特性。我们的目标是在未来的工作中为特定于程序的属性开发一个单独的离线验证器(见第7节)。

Move模块或事务脚本的二进制格式编码实体表的集合，如常量、类型签名、结构定义和过程定义。验证人进行的检查分为三类:

- 结构检查，确保字节码表是格式良好的。这些检查会发现错误，如非法表索引、重复的表项和非法类型签名(如对引用的引用)。
- 过程体的语义检查。这些检查检测错误，如不正确的过程参数、空引用和复制资源。
- 将结构类型和过程签名的使用与它们的声明模块相链接。这些检查检测错误，例如非法调用内部过程和使用与其声明不匹配的过程标识符。

在本节的其余部分中，我们将描述语义验证和链接的各个阶段。

**控制流图构造** 。 验证者通过将指令序列分解为一组基本块(注意，这些基本块与区块链中的事务“块”无关)来构造一个控制流图。每个基本块包含一个连续的指令序列;所有指令集都被划分到块中。这种分解保证了分支只以某些开始的基本块为目标。分解还试图确保生成的块是最大的。然而，字节码验证器的可靠性并不依赖于最大性。

**堆栈平衡检查** 。 堆栈平衡检查确保被调用方不能访问属于调用方的堆栈位置。基本块的执行发生在局部数组的上下文的变量和堆栈中。该过程的参数是局部变量数组的前缀。跨过程调用传递参数和返回值是通过堆栈完成的。当一个过程开始执行时，它的参数已经加载到它的参数中。假设当一个过程开始执行时，堆栈高度为n，有效的字节码必须满足一个不变条件，即当执行到一个基本块的末尾时，栈高为n。验证者通过单独分析每个基本块并计算每个指令对栈高的影响来确保这一点。它检查高度不低于n，并且在基本块出口为n。唯一的例外是一个以返回指令结尾的块，其中高度必须是n+m(其中m是过程返回的值的数量)。

**类型检查** 。 验证器的第二阶段检查每条指令和过程(包括构建过程和用户定义过程)是否使用适当类型的参数调用。指令的操作数是位于局部变量或堆栈上的值。过程的局部变量类型已经在字节码中提供。然而，堆栈值的类型是推断出来的。每个基本块分别执行此推理和每个操作的类型检查。由于每个基本块开始时的堆栈高度为n，并且在执行该块时不会低于n，所以我们只需要为从n开始的堆栈后缀建模，以检查块指令的类型。我们使用类型堆栈对这个后缀进行建模，当处理基本块中的指令序列时，类型将被推入和弹出。类型堆栈和静态已知的局部变量类型足以对每个字节码指令进行类型检查。

**类别检查** 。 验证者在类型检查阶段通过以下附加检查强制执行资源安全:

- 资源不可复制:`CopyLoc`不用于`resourse`类型的本地变量，并且`ReadRef`不用于类型为`resource`值引用的堆栈值。
- 资源不能被销毁:`PopUnrestricted`不用于`resourse`类型的堆栈位置，`StoreLoc`不用于已经拥有资源的本地变量，`WriteRef`不用于对`resource`类型值的引用。
- 资源必须被使用: 当一个过程返回时，没有局部变量可以保存资源值，并且计算堆栈中被调用方的字段必须只保存过程的返回值。

`no-resource`结构类型不能具有`resource`类型字段，因此不能通过(例如)用`resource`字段复制`no-resource`结构来破坏这些检查。

资源不能被因错误而中断的程序执行所破坏。正如我们在第4.2节中所解释的，事务脚本的部分执行所产生的任何状态更改都不会提交给全局状态。这意味着在运行时失败时位于堆栈或局部变量中的资源将(有效地)返回到事务开始执行之前的位置。

原则上，可以通过不终止的程序执行使资源不可访问。然而，第5.1节中描述的气体计量方案确保了Move程序的执行总是终止。用完gas的执行会因错误而停止，这不会导致资源的丢失(如上所述)。

**引用检查** 。 使用静态和动态分析相结合的方法检查引用的安全性。静态分析以类似于Rust类型系统的方式使用borrow检查，但是在字节码级别而不是源代码级别执行。这些参考检查确保了两个强属性:

- 所有引用都指向已分配的存储(即，没有空引用)
- 所有引用都具有安全的读和写访问权限。引用要么是共享的(没有写访问和自由读访问)，要么是独占的(只有有限的读和写访问)

为了确保这些属性对通过`BorrowGlobal`创建的全局存储中的引用有效，字节码解释器执行轻量级动态引用计数。解释器跟踪每个已发布资源的未完成引用的数量。如果在对全局资源的引用仍然存在时借用或移动了该资源，则使用此信息停止，并出现错误。

**与全局状态连接**

![ZSnXTI.png](https://s2.ax1x.com/2019/06/21/ZSnXTI.png?ynotemdtimestamp=1562746207621)

在字节码验证过程中，验证器假设当前代码单元使用的外部结构类型和过程ID存在并被真实地表示。链接步骤检查这种假设通过阅读的结构和过程声明全局状态Σ和确保声明匹配使用。具体地说，链接器检查全局状态中的下列声明是否匹配它们在当前代码单元中的用法:

- 结构声明(名称和类型):
- 过程签名(名称、可见性、形式参数类型和返回类型)。

### Move虚拟机 ：把所有的东西都放一起

![ZSMDYt.png](https://s2.ax1x.com/2019/06/21/ZSMDYt.png?ynotemdtimestamp=1562746207621)

Move虚拟机的作用是执行一个区块𝐵从全球的交易状态Σ并产生一个事务影响𝐸代表修改全局状态。影响𝐸可以应用于Σ生成状态Σ′作为区块𝐵的执行的结果。将效果与实际状态更新分离，允许VM在执行失败的情况下实现事务语义。

直观地说，事务效果表示对帐户子集的全局状态的更新。事务效果具有与全局状态相同的结构:它是一个从帐户地址到帐户的部分映射，其中包含Move模块和资源值的规范化序列化表示。规范化序列化实现了从Move模块或资源到字节数组的与语言无关的1-1 function。

为了从状态Σ𝑖−1执行区块𝐵, VM从B中获取一个事务𝑇𝑖 。执行它并产生产生影响𝐸𝑖。,然后应用𝐸𝑖到Σ𝑖−1上去生产状态Σ𝑖，用作区块中生产一个交易的初始状态。整个块的effect有序组合构成了区块的effects。

每个事务都根据工作流进行处理，工作流包括验证事务中的字节码和检查事务发送方的签名等步骤。

现在，块中的事务由VM按顺序执行，但是Move语言被设计为支持并行执行。原则上,执行一个事务可以产生一系列的读取以及一组写𝐸影响。块中的每个事务都可以推测地并行执行，只有当其读/写集与块中的另一个事务冲突时才可以重新执行。检查冲突非常简单，因为Move的树内存模型允许我们使用全局内存单元的访问路径惟一地标识它。如果虚拟机性能成为Libra区块链的瓶颈，我们将在未来探索投机性的执行方案。

### move下一步做什么

到目前为止，我们已经设计并实现了Move的以下组件:

- 一个适合区块链执行的编程模型。
- 一种适合这种可编程模型的字节码语言
- 用于实现具有强大数据抽象和访问控制的库的模块系统
- 由序列化器/反序列化器、字节码验证器和字节码解释器组成的虚拟机。

尽管取得了这些进展，但前面还有很长的路要走。最后，我们讨论了一些近期的下一步举措和长期的Move计划。

**实现核心libra区块链功能:** 我们将使用Move来实现Libra区块链的核心功能:账户、libra coin、libra储备管理、验证器节点的添加和删除、收取和分配交易费用、冷钱包等。这项工作已在进行中

**新的语言特性**: 我们将向Move语言添加参数多态性(泛型)、集合和事件。参数多态性不会破坏Move现有的安全性和可验证性保证。

此外，我们将开发一个可信的机制，用于版本控制和更新Move模块、事务脚本和发布资源。

**提高开发人员的体验： ** Move IR 是被来开发用作 Move字节码校验器和虚拟机的测试工具。要运行这些组件，IR编译器必须故意生成坏的字节码，这些坏的字节码将被(例如)字节码验证器拒绝。这意味着尽管IR适用于原型化移动程序，但它并不特别友好。为了使Move对第三方开发更具吸引力，我们将改进IR并致力于开发符合人体工程学的Move源语言。

**形式化描述与验证方法**: 我们将创建一个逻辑规范语言和自动化的形式化验证工具，该工具利用了Move的验证友好设计(参见3.4节)。验证工具链将检查特定于程序的功能正确性属性，这些属性超出了Move字节码验证器执行的安全保证(第5.2节)。我们最初的重点是指定和验证实现Libra区块链核心功能的模块

我们的长期目标是促进一种正确性文化，在这种文化中，用户将通过模块的正式规范来了解其功能。理想情况下，没有一个Move程序员愿意与模块交互，除非它有一个全面的正式规范，并且经过验证符合该规范。然而，实现这一目标将面临若干技术和社会挑战。验证工具应该是精确和直观的。规范必须是模块化和可重用的，但是可读性足够强，可以作为模块行为的有用文档。

**支持第三方移动模块**： 我们将开发一条第三方模块发布的路径。为Libra用户和第三方开发人员创造良好的体验是一个重大的挑战。首先，向一般应用程序敞开大门一定不能影响系统对核心支付场景和相关金融应用程序的可用性。其次，我们希望避免欺诈、投机和漏洞百出的软件带来的声誉风险。在鼓励高质量软件的同时建立一个开放的系统是一个难题。为高可信模块创建一个市场，并为验证移动代码提供有效的工具等步骤将会有所帮助。

### 附录

A Move 语言参考

![img](https://i.loli.net/2019/06/21/5d0ca83c1e82411308.jpg?ynotemdtimestamp=1562746207621)

![ZSYMPH.jpg](https://s2.ax1x.com/2019/06/21/ZSYMPH.jpg?ynotemdtimestamp=1562746207621)

![ZSYBzn.jpg](https://s2.ax1x.com/2019/06/21/ZSYBzn.jpg?ynotemdtimestamp=1562746207621)

[![ZStNOx.jpg](https://s2.ax1x.com/2019/06/21/ZStNOx.jpg?ynotemdtimestamp=1562746207621)
