<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ClimbYang的记录</title>
  
  <subtitle>blockchain</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yp945.github.io/"/>
  <updated>2019-07-11T02:08:54.793Z</updated>
  <id>https://yp945.github.io/</id>
  
  <author>
    <name>ClimbYang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>evm源码分析第三篇</title>
    <link href="https://yp945.github.io/2019/07/11/evm-analysis-3/"/>
    <id>https://yp945.github.io/2019/07/11/evm-analysis-3/</id>
    <published>2019-07-11T01:35:08.000Z</published>
    <updated>2019-07-11T02:08:54.793Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;上一篇我们介绍了创建合约的交易是如何执行的，这一篇我们分析普通交易是如何在evm里面被执行的&lt;/p&gt;
    
    </summary>
    
      <category term="ethereum" scheme="https://yp945.github.io/categories/ethereum/"/>
    
      <category term="evm" scheme="https://yp945.github.io/categories/ethereum/evm/"/>
    
    
      <category term="ethereum" scheme="https://yp945.github.io/tags/ethereum/"/>
    
      <category term="evm" scheme="https://yp945.github.io/tags/evm/"/>
    
  </entry>
  
  <entry>
    <title>evm源码分析第一篇</title>
    <link href="https://yp945.github.io/2019/07/11/evm-analysis-1/"/>
    <id>https://yp945.github.io/2019/07/11/evm-analysis-1/</id>
    <published>2019-07-11T01:35:08.000Z</published>
    <updated>2019-07-11T02:08:47.107Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;evm源码分析分为3篇去讲解，所有的代码解析基于以太坊&lt;code&gt;go-ethereum-1.8.23-release&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ethereum" scheme="https://yp945.github.io/categories/ethereum/"/>
    
      <category term="evm" scheme="https://yp945.github.io/categories/ethereum/evm/"/>
    
    
      <category term="ethereum" scheme="https://yp945.github.io/tags/ethereum/"/>
    
      <category term="evm" scheme="https://yp945.github.io/tags/evm/"/>
    
  </entry>
  
  <entry>
    <title>evm源码分析第二篇</title>
    <link href="https://yp945.github.io/2019/07/11/evm-analysis-2/"/>
    <id>https://yp945.github.io/2019/07/11/evm-analysis-2/</id>
    <published>2019-07-11T01:35:08.000Z</published>
    <updated>2019-07-11T02:08:36.138Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这一篇我们主要分析交易是如何被evm解释器解释执行的。&lt;/p&gt;
    
    </summary>
    
      <category term="ethereum" scheme="https://yp945.github.io/categories/ethereum/"/>
    
      <category term="evm" scheme="https://yp945.github.io/categories/ethereum/evm/"/>
    
    
      <category term="ethereum" scheme="https://yp945.github.io/tags/ethereum/"/>
    
      <category term="evm" scheme="https://yp945.github.io/tags/evm/"/>
    
  </entry>
  
  <entry>
    <title>Move IR 示例代码解读</title>
    <link href="https://yp945.github.io/2019/07/10/libra-moveIR-exampleCode/"/>
    <id>https://yp945.github.io/2019/07/10/libra-moveIR-exampleCode/</id>
    <published>2019-07-10T08:07:54.000Z</published>
    <updated>2019-07-10T08:17:01.769Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Move-IR-示例代码解读&quot;&gt;&lt;a href=&quot;#Move-IR-示例代码解读&quot; class=&quot;headerlink&quot; title=&quot;Move IR 示例代码解读&quot;&gt;&lt;/a&gt;Move IR 示例代码解读&lt;/h3&gt;&lt;p&gt;本节描述如何在Move中间表示(IR)中编写事务脚本和模块。IR是即将到来的Move源代码语言的早期(且不稳定)先驱。Move IR是一个覆盖于Move字节码之上的薄薄的语法层，用于测试字节码验证器和虚拟机，它对开发人员不是特别友好。它的级别足够高，可以编写人类可读的代码，但又足够低，可以直接编译以移动字节码。&lt;/p&gt;
&lt;p&gt;接下来，我将展示一些Move IR片段。关于如何在本地编译、运行和修改这些示例来学习。&lt;code&gt;libra/language/README.md&lt;/code&gt; and &lt;code&gt;libra/language/compiler/README.md&lt;/code&gt;解释了如何做到这一点。&lt;br&gt;
    
    </summary>
    
      <category term="libra" scheme="https://yp945.github.io/categories/libra/"/>
    
      <category term="move语言" scheme="https://yp945.github.io/categories/libra/move%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="libra" scheme="https://yp945.github.io/tags/libra/"/>
    
      <category term="move语言" scheme="https://yp945.github.io/tags/move%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Move:一种可编程资源语言</title>
    <link href="https://yp945.github.io/2019/07/10/libra-move-paper/"/>
    <id>https://yp945.github.io/2019/07/10/libra-move-paper/</id>
    <published>2019-07-10T08:07:23.000Z</published>
    <updated>2019-07-10T08:38:29.769Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Move-一种可编程资源语言&quot;&gt;&lt;a href=&quot;#Move-一种可编程资源语言&quot; class=&quot;headerlink&quot; title=&quot;Move:一种可编程资源语言&quot;&gt;&lt;/a&gt;Move:一种可编程资源语言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;. 我们为Libra区块链提供了一种安全灵活的编程语言Move， Move是一种可执行的字节码语言，用于实现自定义事务和智能合约。Move的关键特性是能够使用受linear启发的语义定义自定义资源类型。资源永远不能被复制或者被隐式丢弃，只能在程序的存储位置间移动。这些安全保证由Move的类型系统静态执行，尽管有这些特殊保护，资源仍然是一种普通的程序值，它们可以存储在数据结构中作为参数传递给处理逻辑，等等。资源优先是一种很普遍的观念。程序员不仅可以实现安全的数字资产，还可以编写正确的业务用于包装资产和强制访问控制策略的逻辑。Move的安全性和表达性使我们能够在Move中实现Libra协议的重要部分，包括Libra Coin，事务处理和验证器管理.&lt;/p&gt;
    
    </summary>
    
      <category term="libra" scheme="https://yp945.github.io/categories/libra/"/>
    
      <category term="move语言" scheme="https://yp945.github.io/categories/libra/move%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="libra" scheme="https://yp945.github.io/tags/libra/"/>
    
      <category term="move语言" scheme="https://yp945.github.io/tags/move%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>pbft共识算法问题答案</title>
    <link href="https://yp945.github.io/2019/07/10/consensus-pbft-QA/"/>
    <id>https://yp945.github.io/2019/07/10/consensus-pbft-QA/</id>
    <published>2019-07-10T02:01:27.000Z</published>
    <updated>2019-07-10T08:34:42.362Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是针对上一篇提出的进行一个详细的解答&lt;/p&gt;
    
    </summary>
    
      <category term="共识算法" scheme="https://yp945.github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="pbft" scheme="https://yp945.github.io/tags/pbft/"/>
    
  </entry>
  
  <entry>
    <title>pbft共识算法</title>
    <link href="https://yp945.github.io/2019/07/09/consensus-pbft/"/>
    <id>https://yp945.github.io/2019/07/09/consensus-pbft/</id>
    <published>2019-07-09T02:01:27.000Z</published>
    <updated>2019-07-10T08:28:23.230Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;PBFT 是 parctical Byzantine Fault Tolerance（实用拜占庭容错算法）的缩写，它是由BFT算法演化出来的， 所有的BFT算法都为了解决一个问题，那就是在一个不可信的网络里，各个节点如何达成共识。这类问题被称为拜占庭将军问题。什么是拜占庭将军问题呢？拜占庭位于如今的土耳其的伊斯坦布尔，是古代东罗马帝国的首都。拜占庭罗马帝国国土辽阔，为了达到防御目的，每块封地都驻扎一支由将军统领的军队，每个军队都分隔很远，将军与将军之间只能靠信差传递消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定影响将军们达成一致共识。在已知有将军是叛徒的情况下，其余忠诚的将军如何达成一致协议的问题，这就是拜占庭将军问题。&lt;/p&gt;
    
    </summary>
    
      <category term="共识算法" scheme="https://yp945.github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="pbft" scheme="https://yp945.github.io/tags/pbft/"/>
    
  </entry>
  
</feed>
